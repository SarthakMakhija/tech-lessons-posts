<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" href="/favicon.png">

  <title>
  Count-min sketch - tech-lessons.in
  </title>
  <meta name="description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream." />
  <meta name="author" content="Sarthak Makhija" />
  
     <meta property="og:image" content="/countminsketch-title.png" />
  <meta name="generator" content="Hugo 0.140.1"><link rel="stylesheet" href="/css/styles.css" />

  
  

  <meta property="og:url" content="//localhost:1313/en/blog/count_min_sketch/">
  <meta property="og:site_name" content="tech-lessons.in">
  <meta property="og:title" content="Count-min sketch">
  <meta property="og:description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2023-02-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-02-24T00:00:00+00:00">
    <meta property="article:tag" content="Count-Min Sketch">
    <meta property="article:tag" content="Probabilistic Data Structure">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Count-min sketch">
  <meta name="twitter:description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream.">

  
  <meta itemprop="name" content="Count-min sketch">
  <meta itemprop="description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream.">
  <meta itemprop="datePublished" content="2023-02-24T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-02-24T00:00:00+00:00">
  <meta itemprop="wordCount" content="2339">
  <meta itemprop="keywords" content="Count-Min Sketch,Probabilistic Data Structure">

  
</head>
<body class="dark:bg-gray-800 dark:text-white relative flex flex-col min-h-screen"><header class="container flex justify-between md:justify-between gap-4 flex-wrap p-6 mx-auto relative">
  <a href="//localhost:1313/en/" class="capitalize font-extrabold text-2xl">
    
    <img src="/logo.png" alt="tech-lessons.in" class="h-8 max-w-full" />
    
  </a>
  <button class="mobile-menu-button md:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <line x1="4" y1="8" x2="20" y2="8" />
      <line x1="4" y1="16" x2="20" y2="16" />
    </svg>
  </button>
  <ul class="mobile-menu absolute z-10 px-6 pb-6 md:p-0 top-full left-0 w-full md:w-auto md:relative hidden md:flex flex-col md:flex-row items-end md:items-center gap-4 lg:gap-6 bg-white dark:bg-gray-800">

    
    <li><a href="/en/">Home</a></li>
    
    <li><a href="/en/blog">Blogs</a></li>
    
    <li><a href="/en/page/about/">About Me</a></li>
    
    <li><a href="/en/page/projects/">My projects</a></li>
    

    

    
    <li class="grid place-items-center">
      <span class="open-search inline-block cursor-pointer">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <circle cx="10" cy="10" r="7" />
          <line x1="21" y1="21" x2="15" y2="15" />
        </svg>
      </span>
    </li>
    

    
  </ul>
</header>
<main class="flex-1">
  
  

  
  <div class="relative max-w-5xl mx-auto px-4">
    <img src="/countminsketch-title.png" class="rounded-lg shadow-sm w-full object-contain" />
    
    <figcaption class="font-extralight text-xs"><i>Background by Fernando Paredes Murillo on Unsplash</i></figcaption>
    
    
    <div class="absolute top-4 right-8 rounded shadow bg-white text-gray-900 dark:bg-gray-900 dark:text-white px-2 py-0.5">
      
  
    February 24, 2023
  


    </div>
    
  </div>
  

  <article class="prose lg:prose-lg mx-auto my-8 dark:prose-dark px-4 max-w-5xl">

    <h1 class="text-2xl font-bold mb-2">Count-min sketch</h1>
    
    <h5 class="text-sm flex items-center flex-wrap">
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <rect x="4" y="5" width="16" height="16" rx="2" />
        <line x1="16" y1="3" x2="16" y2="7" />
        <line x1="8" y1="3" x2="8" y2="7" />
        <line x1="4" y1="11" x2="20" y2="11" />
        <rect x="8" y="15" width="2" height="2" />
      </svg>
      Posted on 
  
    February 24, 2023
  


      
        &nbsp;&bull;&nbsp;
      
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <circle cx="12" cy="12" r="9" />
        <polyline points="12 7 12 12 15 15" />
      </svg>
      11&nbsp;minutes
      &nbsp;&bull;
      <svg xmlns="http://www.w3.org/2000/svg" class="mx-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <path d="M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <path d="M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <line x1="3" y1="6" x2="3" y2="19" />
        <line x1="12" y1="6" x2="12" y2="19" />
        <line x1="21" y1="6" x2="21" y2="19" />
      </svg>
      2339&nbsp;words
      
    </h5>
    

    <details id="TableOfContents" class="px-4 mt-4 bg-gray-100 dark:bg-gray-700 rounded toc">
    <summary class="flex items-center font-bold py-2 px-4 cursor-pointer justify-between select-none text-black dark:text-white">
      <span>Table of contents</span>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <polyline points="6 9 12 15 18 9"></polyline>
     </svg>
    </summary>

    <ul class="mt-2 pb-4">
        

        
        <li>
        <a href="#understanding-count-min-sketch">Understanding Count-min Sketch</a>
        

        
        </li><li>
        <a href="#adding-tests-for-increment-and-estimate">Adding tests for increment and estimate</a>
        

        
        </li><li>
        <a href="#4-bit-counter">4-bit counter</a>
        

        
        </li><li>
        <a href="#building-count-min-sketch">Building Count-min sketch</a>
        

        
        </li><li>
        <a href="#ristretto">Ristretto</a>
        

        
        </li><li>
        <a href="#code">Code</a>
        

        
        </li><li>
        <a href="#mention">Mention</a>
        

        
        </li><li>
        <a href="#references">References</a>
        </li></ul>
  </details>

    <p>Count-min sketch (CM sketch) is a probabilistic data structure<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> used to estimate the frequency of events in a data stream.</p>
<p>It relies on hash functions to map events to frequencies, but unlike a hash table, it uses only sublinear space at the expense of over-counting some events due to hash collisions. The count–min sketch was invented in 2003 by Graham Cormode and S. Muthu Muthukrishnan.</p>
<h3 id="understanding-count-min-sketch">Understanding Count-min Sketch</h3>
<p>Let&rsquo;s say we want to build a solution to count the frequency of elements in a data stream. One idea would be to use a <code>hashmap</code> with the data element as the key and count as the value. The approach works but does not scale with a data stream comprising billions of elements, the most unique.</p>
<p>We will have two challenges with <code>hashmap</code> in this case:</p>
<ol>
<li>The number of elements in the hashmap will tend towards a billion. The overall space complexity would be O(N)<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></li>
<li>Rehashing can place significant CPU pressure</li>
</ol>
<p>This is where the Count-min sketch comes into the picture. The count-min sketch is a probabilistic data structure that can <strong>estimate</strong> the frequency of elements by using sublinear space at the expense of over-counting some elements due to hash collisions.</p>
<div class="align-center">
    <img src="/countminsketch.png"/>
</div>
<p>Count-min sketch is represented as a D*W matrix, where D is the total number of hash functions (or depth) and W is the width or the number of counters per hash function. The matrix is initialized with zero at the beginning. A count-min sketch can be represented with the following structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">const</span> depth = <span style="color:#bd93f9">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> CountMinSketch <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    matrix        [depth]row
</span></span><span style="display:flex;"><span>    seeds         [depth]<span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    totalCounters <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> row []<span style="color:#8be9fd">byte</span>
</span></span></code></pre></div><p><code>CountMinSketch</code> contains the following:</p>
<ol>
<li>A matrix of a byte array to store the counters. Each row will have <code>W</code> cells, and each cell will contain a byte.</li>
<li>The total number of rows (or the total number of hash functions) is limited to four in the above code. So, D here is 4.</li>
<li>An array of seed values of type <code>uint64</code> will be used to generate the hash of the data element.</li>
<li>Total number of counters</li>
</ol>
<blockquote>
<p>We plan to use a &ldquo;four-bit counter&rdquo; approach, with the lower four bits of a byte to store the counter for a key <em>K1</em> and the upper four bits to hold the counter for another key <em>K2</em>. That means a byte will store the counts for two keys.</p>
</blockquote>
<p><em>From now on, we will use the term &ldquo;key&rdquo; over &ldquo;data element&rdquo;</em>. Count-min sketch supports two operations - <code>increment(key)</code> and <code>estimate(key)</code>. Let&rsquo;s understand the working of these operations.</p>
<p>The idea behind the <code>increment</code> operation can be summarized as follows:</p>
<ol>
<li>Run D hash functions on the given key (hash0, hash1 and hash2 in the image above).</li>
<li>Find a column index in the matrix by performing <code>hashValue % totalCounters</code>.</li>
<li>Increment the value at the identified matrix cell using <a href="#4-bit-counter">four-bit counter approach</a>
.</li>
</ol>
<p>The idea behind the <code>estimate</code> operation is similar to the <code>increment</code> operation.</p>
<ol>
<li>Run D hash functions on the given key (hash0, hash1 and hash2 in the above image).</li>
<li>Find a column index in the matrix by performing <code>hashValue % totalCounters</code>.</li>
<li>Return the <strong>minimum value</strong> from all the identified matrix cells.</li>
</ol>
<blockquote>
<p>We return the <strong>minimum value</strong> from all the identified matrix cells to account for hash conflicts between keys. 2 keys might get the same column index (<code>hashValue % totalCounters</code>) for the 0th row, but they might get different column indices for the 1st row. So, we take the minimum counter value from all the identified matrix cells to reduce the impact of hash conflicts between keys.</p>
</blockquote>
<h3 id="adding-tests-for-increment-and-estimate">Adding tests for increment and estimate</h3>
<p>Let&rsquo;s add a test for <code>increment</code> and <code>estimate</code> operations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">TestGetsTheEstimateForKeysInAStream</span>(t <span style="color:#ff79c6">*</span>testing.T) {
</span></span><span style="display:flex;"><span>    stream <span style="color:#ff79c6">:=</span> []model.Slice{
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;A&#34;</span>)), 
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;B&#34;</span>)),
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;A&#34;</span>)), 
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;C&#34;</span>)),
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;B&#34;</span>)), 
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;A&#34;</span>)),
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;B&#34;</span>)), 
</span></span><span style="display:flex;"><span>        model.<span style="color:#50fa7b">NewSlice</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;C&#34;</span>)),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    expectedCounts <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">byte</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;A&#34;</span>: <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;B&#34;</span>: <span style="color:#bd93f9">3</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;C&#34;</span>: <span style="color:#bd93f9">2</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//instantiate countMinSketch with ten counters
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    countMinSketch <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">newCountMinSketch</span>(<span style="color:#bd93f9">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//increment
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> _, key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> stream {
</span></span><span style="display:flex;"><span>        countMinSketch.<span style="color:#50fa7b">Increment</span>(key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//estimate the count
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> _, key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> stream {
</span></span><span style="display:flex;"><span>        count <span style="color:#ff79c6">:=</span> countMinSketch.<span style="color:#50fa7b">Estimate</span>(key)
</span></span><span style="display:flex;"><span>       <span style="color:#ff79c6">if</span> count &lt; expectedCounts[key.<span style="color:#50fa7b">AsString</span>()] {
</span></span><span style="display:flex;"><span>                t.<span style="color:#50fa7b">Fatalf</span>(
</span></span><span style="display:flex;"><span>                    <span style="color:#f1fa8c">&#34;Expected at least the count %v for key %v, received %v&#34;</span>, 
</span></span><span style="display:flex;"><span>                    expectedCounts[key.<span style="color:#50fa7b">AsString</span>()], 
</span></span><span style="display:flex;"><span>                    key.<span style="color:#50fa7b">AsString</span>(), 
</span></span><span style="display:flex;"><span>                    count
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s quickly understand the test:</p>
<ol>
<li>Create a <code>stream</code> of keys. Keys are represented by the <code>Slice</code> abstraction, which is a wrapper over a byte slice.</li>
<li>Create a count-min sketch with ten counters (width as 10)</li>
</ol>
<ul>
<li>We will see in the code that the counters are in the power of 2.</li>
</ul>
<ol start="3">
<li>Increment the count for all the keys in the stream.</li>
<li>Assert the estimate of count for all the keys</li>
</ol>
<blockquote>
<p>As a part of the assertion, we want to ensure that the estimated count is &ldquo;at least&rdquo; equal to the expected count. In the case of hash collisions between two keys, an estimate of the count might be higher than the expected count. Hence, we hope that the estimated count is &ldquo;at least&rdquo; equal to the expected count.</p>
</blockquote>
<h3 id="4-bit-counter">4-bit counter</h3>
<p>The idea behind the four-bit counter deserves its mention.</p>
<ul>
<li>We can represent a maximum value of 15 <code>(00001111)</code> with four bits. This implies that the counter should freeze the moment it reaches 15.</li>
<li>We need to use the lower and the upper four bits to represent counters for two different keys.</li>
<li>Let&rsquo;s use the <em>lower four bits to store the counter for even positions of the matrix</em> and <em>higher four bits for odd positions of the matrix</em>.</li>
</ul>
<div class="align-center">
    <img src="/4bitcounter.png"/>
</div>
<ul>
<li>This means if the number is even, we need to increment the lower four bits only if the counter represented by those bits has yet to reach 15.</li>
<li>If the number is odd, we need to increment the higher four bits only if the counter represented by those bits has yet to reach 15. To ensure that the counter represented by the higher four bits has not reached 15, we can perform a right shift by four, followed by an AND operation with 0x0f.</li>
</ul>
<div class="align-center">
    <img src="/4bitcounterwithshift.png"/>
</div>
<ul>
<li>Imagine a binary value <code>11110000</code> at some matrix index. Also, consider that the <code>Increment</code> operation is called, and the <code>position</code> is an odd number.</li>
<li>We should increment the higher four bits because we have an odd-numbered position. But, the binary value already has the maximum value for an odd number. To ensure that the increment operation does not result in an overflow, we do a right shift by four (<code>0b11110000 &gt;&gt; 4</code>), which gives us <code>00001111</code>. Now, we perform an AND operation with <code>0x0f (00001111)</code> to ensure we only get the lower four bits. We ensure that the value is less than 15 before incrementing. In this case, we do not increment because the counter has reached 15.</li>
</ul>
<p>Now is the right time to build a count-min sketch.</p>
<h3 id="building-count-min-sketch">Building Count-min sketch</h3>
<p>Let&rsquo;s understand the critical aspects of <code>newCountMinSketch</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">const</span> depth = <span style="color:#bd93f9">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> row []<span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> CountMinSketch <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   matrix        [depth]row
</span></span><span style="display:flex;"><span>   seeds         [depth]<span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>   totalCounters <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">newCountMinSketch</span>(counters <span style="color:#8be9fd">int</span>) <span style="color:#ff79c6">*</span>CountMinSketch {
</span></span><span style="display:flex;"><span>    nextPowerOf2 <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">func</span>(counters <span style="color:#8be9fd">int64</span>) <span style="color:#8be9fd">int64</span> {
</span></span><span style="display:flex;"><span>        counters<span style="color:#ff79c6">--</span>
</span></span><span style="display:flex;"><span>        counters <span style="color:#ff79c6">|=</span> counters <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>        counters <span style="color:#ff79c6">|=</span> counters <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span>        counters <span style="color:#ff79c6">|=</span> counters <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">4</span>
</span></span><span style="display:flex;"><span>        counters <span style="color:#ff79c6">|=</span> counters <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">8</span>
</span></span><span style="display:flex;"><span>        counters <span style="color:#ff79c6">|=</span> counters <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">16</span>
</span></span><span style="display:flex;"><span>        counters <span style="color:#ff79c6">|=</span> counters <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">32</span>
</span></span><span style="display:flex;"><span>        counters<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> counters
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//initialize the source to generate seed values and set the total counters to be a power of 2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//if the user-specified counter is 10, we get a total of 16 counters
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    source, updatedCounters <span style="color:#ff79c6">:=</span> rand.<span style="color:#50fa7b">New</span>(rand.<span style="color:#50fa7b">NewSource</span>(time.<span style="color:#50fa7b">Now</span>().<span style="color:#50fa7b">UnixNano</span>())), <span style="color:#50fa7b">nextPowerOf2</span>(<span style="color:#8be9fd;font-style:italic">int64</span>(counters))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//instantiate CountMinSketch
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    countMinSketch  <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>CountMinSketch{totalCounters: <span style="color:#8be9fd;font-style:italic">uint64</span>(updatedCounters)}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> index <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; index &lt; depth; index<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//generate a new seed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        countMinSketch.seeds[index] = source.<span style="color:#50fa7b">Uint64</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//create a new byte array using the make function and set the newly created byte array at the current index of the matrix
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        countMinSketch.matrix[index] = <span style="color:#8be9fd;font-style:italic">make</span>(row, updatedCounters<span style="color:#ff79c6">/</span><span style="color:#bd93f9">2</span>) 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> countMinSketch
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The idea behind <code>newCountMinSketch</code> can be summarized as follows:</p>
<ol>
<li>Create a new source for generating seed values and set the counter as a power of 2.</li>
<li>Set <code>totalCounters</code> inside <code>CountMinSketch</code></li>
<li>Iterate from index = 0 to depth-1 and do the following:</li>
</ol>
<ul>
<li>Generate a new seed value of type <code>uint64</code></li>
<li>Create a new byte array of size <code>updatedCounters/2</code> using the <code>make</code> function</li>
<li>Set the newly created byte array in the matrix at <code>index</code></li>
</ul>
<blockquote>
<p>Every row in the matrix has a byte array of size <code>updatedCounters/2</code>. Using the four-bit counter approach, each byte stores the counters for two keys. This means that we can reduce the total number of counters by 2. With the input counter as 18, we get the value of <code>updatedCounters</code> as 32. Using the four-bit counter approach, we end up with 16 cells (32/2) for each row, with each cell containing a byte.</p>
</blockquote>
<p>The idea behind <code>Increment</code> can be summarized as follows:</p>
<ol>
<li>Iterate from index = 0 to depth-1 and do the following:</li>
</ol>
<ul>
<li>Run the hash function for the given key and get the hashed value.</li>
<li>Identify the <code>columnIndex</code> using the hashed value by executing <code>hashedValue % totalCounters</code>.</li>
<li>Increment the value in the matrix cell at the position identified by a pair of <code>(index, columnIndex)</code>.</li>
</ul>
<blockquote>
<p>Increment operation will increment either the upper or lower four bits of the byte depending on the matrix cell position.</p>
</blockquote>
<p>This is how the above approach can be implemented in golang:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (countMinSketch <span style="color:#ff79c6">*</span>CountMinSketch) <span style="color:#50fa7b">Increment</span>(key model.Slice) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> index <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; index &lt; depth; index<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//compute the hash value
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        hash        <span style="color:#ff79c6">:=</span> countMinSketch.<span style="color:#50fa7b">runHash</span>(key, <span style="color:#8be9fd;font-style:italic">uint32</span>(countMinSketch.seeds[index]))
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//get the current row (instance of type row is an alias for []byte)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        currentRow  <span style="color:#ff79c6">:=</span> countMinSketch.matrix[index]
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//increment the value from the current row at an index=hash % countMinSketch.totalCounters
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        currentRow.<span style="color:#50fa7b">incrementAt</span>(hash <span style="color:#ff79c6">%</span> countMinSketch.totalCounters)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (currentRow row) <span style="color:#50fa7b">incrementAt</span>(position <span style="color:#8be9fd">uint64</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//get the index
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    index <span style="color:#ff79c6">:=</span> position <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//if the position is an odd number, upper four bits store the counter value,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//else lower four bits store the counter value
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    shift <span style="color:#ff79c6">:=</span> (position <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0x01</span>) <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">4</span>    
</span></span><span style="display:flex;"><span>    isLessThan15 <span style="color:#ff79c6">:=</span> (currentRow[index]<span style="color:#ff79c6">&gt;&gt;</span>shift)<span style="color:#ff79c6">&amp;</span><span style="color:#bd93f9">0x0f</span> &lt; <span style="color:#bd93f9">0x0f</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//if the value is less than 15, increment
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> isLessThan15 {
</span></span><span style="display:flex;"><span>       currentRow[index] = currentRow[index] <span style="color:#ff79c6">+</span> (<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> shift)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The idea behind <code>Estimate</code> can be summarized as follows:</p>
<ol>
<li>Iterate from index = 0 to depth-1 and do the following:</li>
</ol>
<ul>
<li>Run the hash function for the given key and get the hashed value.</li>
<li>Identify the <code>columnIndex</code> based on the hashed value by executing <code>hashedValue % totalCounters</code>.</li>
<li>Identify the minimum value from all the eligible cells.</li>
</ul>
<p>This is how the above approach can be implemented in golang:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (countMinSketch <span style="color:#ff79c6">*</span>CountMinSketch) <span style="color:#50fa7b">Estimate</span>(key model.Slice) <span style="color:#8be9fd">byte</span> {
</span></span><span style="display:flex;"><span>   min <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#bd93f9">255</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> index <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; index &lt; depth; index<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//compute the hash value
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        hash       <span style="color:#ff79c6">:=</span> countMinSketch.<span style="color:#50fa7b">runHash</span>(key, <span style="color:#8be9fd;font-style:italic">uint32</span>(countMinSketch.seeds[index]))
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//get the current row (an instance of type row is an alias for []byte)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        currentRow <span style="color:#ff79c6">:=</span> countMinSketch.matrix[index]
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//get the value from the current row at an index=hash % countMinSketch.totalCounters and find the minimum value 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> valueAt <span style="color:#ff79c6">:=</span> currentRow.<span style="color:#50fa7b">getAt</span>(hash <span style="color:#ff79c6">%</span> countMinSketch.totalCounters); valueAt &lt; min {
</span></span><span style="display:flex;"><span>            min = valueAt
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> min
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (currentRow row) <span style="color:#50fa7b">getAt</span>(position <span style="color:#8be9fd">uint64</span>) <span style="color:#8be9fd">byte</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//get the index
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    index <span style="color:#ff79c6">:=</span> position <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//if the position is an odd number, the upper four bits store the counter value,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//else lower four bits store the counter value
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    shift <span style="color:#ff79c6">:=</span> (position <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0x01</span>) <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//perform the shift (shift would be either 0 or 4) 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//perform an AND operation with 0x0f, which 00001111
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> (currentRow[index] <span style="color:#ff79c6">&gt;&gt;</span> shift) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0x0f</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s understand how <a href="https://github.com/dgraph-io/ristretto" target="_blank" rel="noopener">Ristretto</a>
 uses count-min sketch.</p>
<h3 id="ristretto">Ristretto</h3>
<p>Ristretto is a fast, concurrent golang cache library built with a focus on performance and correctness. Ristretto development team set the following requirements for the cache:</p>
<ol>
<li>It should support concurrency</li>
<li>It should maintain a high cache-hit ratio</li>
<li>It should be memory-bounded (limit to configurable max memory usage)</li>
<li>It should scale well as the number of cores and goroutines increases</li>
<li>It should scale well under non-random key access distribution (e.g. Zipf)</li>
</ol>
<p>One of the exciting requirements was &ldquo;maintaining a high cache-hit ratio&rdquo;. To achieve this goal, the development team implemented an LFU (least frequently used) based eviction policy called <a href="https://blog.dgraph.io/refs/TinyLFU%20-%20A%20Highly%20Efficient%20Cache%20Admission%20Policy.pdf" target="_blank" rel="noopener">TinyLFU</a>
.</p>
<p>TinyLFU is an eviction-agnostic admission policy designed to improve hit ratios with very little memory overhead. The main idea is only to let in a new element if its estimate (/cost) exceeds the item being evicted. Ristretto implements <code>TinyLFU</code> using <code>count-min sketch</code> that uses <a href="#4-bit-counter">four-bit counter</a>
.</p>
<p>Let&rsquo;s look at a code snippet from Ristretto.</p>
<p>Ristretto&rsquo;s <code>tinyLFU (policy.go)</code> references <code>cmSketch</code> which implements count-min sketch.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> tinyLFU <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    freq    <span style="color:#ff79c6">*</span>cmSketch
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//fields omitted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (tinyLFU <span style="color:#ff79c6">*</span>tinyLFU) <span style="color:#50fa7b">Push</span>(keys []<span style="color:#8be9fd">uint64</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> keys {
</span></span><span style="display:flex;"><span>        tinyLFU.<span style="color:#50fa7b">Increment</span>(key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//code omitted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (tinyLFU <span style="color:#ff79c6">*</span>tinyLFU) <span style="color:#50fa7b">Increment</span>(key <span style="color:#8be9fd">uint64</span>) {
</span></span><span style="display:flex;"><span>    tinyLFU.freq.<span style="color:#50fa7b">Increment</span>(key)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//code omitted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (tinyLFU <span style="color:#ff79c6">*</span>tinyLFU) <span style="color:#50fa7b">Estimate</span>(key <span style="color:#8be9fd">uint64</span>) <span style="color:#8be9fd">int64</span> {
</span></span><span style="display:flex;"><span>    hits <span style="color:#ff79c6">:=</span> tinyLFU.freq.<span style="color:#50fa7b">Estimate</span>(key)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> hits
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Any access to a key in an LFU-based caching solution should increment the frequency of the accessed key. Instead of implementing the accurate key access count, Ristretto decided to use an estimated access count.</p>
<p>To increase the access count of a key, Ristretto batches the <code>gets</code> in a buffer. When the buffer is full, the buffered keys are handed off to a goroutine for incrementing their frequencies. This is why the <code>Push</code> method of <code>tinyLFU</code> receives a slice of keys of type <code>uint64</code> (<em>hash of the incoming keys</em>).</p>
<p>The <code>Push</code> method results in incrementing the access frequency of the keys by invoking the <code>Increment</code> method on the <code>cmSketch</code> object. <code>cmSketch</code> (<code>sketch.go</code>) is an implementation of the count-min sketch.</p>
<blockquote>
<p>With Ristretto, keys are already hashed, so the type of the parameter for the key in all these methods is <code>uint64</code>.</p>
</blockquote>
<p><code>tinyLFU</code> also provides a method called <code>Estimate</code> responsible for estimating a given key&rsquo;s frequency. To get the estimate, <code>tinyLFU</code> invokes the <code>Estimate</code> method on the <code>cmSketch</code> object and returns the estimated frequency of the key.</p>
<h3 id="code">Code</h3>
<p>The code for this article is available <a href="https://github.com/SarthakMakhija/probabilistic-data-structures/tree/main/frequency" target="_blank" rel="noopener">here</a>
.</p>
<h3 id="mention">Mention</h3>
<p>Thank you, <a href="https://twitter.com/debasishg" target="_blank" rel="noopener">Debasish Ghosh</a>
 for reviewing the article and providing feedback.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Count%e2%80%93min_sketch" target="_blank" rel="noopener">Count-min sketch</a>
</li>
<li><a href="https://florian.github.io/count-min-sketch/" target="_blank" rel="noopener">Count-min sketch</a>
</li>
<li><a href="https://github.com/dgryski/go-tinylfu/blob/master/cm4.go" target="_blank" rel="noopener">Four bit counter</a>
</li>
<li><a href="https://github.com/dgraph-io/ristretto" target="_blank" rel="noopener">Ristretto</a>
</li>
<li><a href="https://blog.dgraph.io/post/introducing-ristretto-high-perf-go-cache/" target="_blank" rel="noopener">Ristretto design</a>
</li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://www.geeksforgeeks.org/introduction-to-the-probabilistic-data-structure/" target="_blank" rel="noopener">Probabilistic data structures</a>
 provide approximate answers to queries about a large dataset rather than exact answers. These data structures are designed to handle large amounts of data in real-time by making trade-offs between accuracy and time and space efficiency.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank" rel="noopener">Big O notation</a>
 In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

  </article>
<div class="tag-list-container">
    <div class="tag-list">
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Count-min sketch</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Probabilistic data structure</p>
        </a>
        
    </div>
</div>



<div class="px-2 mb-2">
  
  <script src="https://giscus.app/client.js"
    data-repo="SarthakMakhija/tech-lessons-comments"
    data-repo-id="R_kgDOJHu3mA"
    data-category="Announcements"
    data-category-id="DIC_kwDOJHu3mM4CUxhS"
    data-mapping="og:title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
  </script>
  
</div>



    </main><footer class="container p-6 mx-auto flex justify-between items-center">
  <span></span>

  <span class="text-base font-thin">
    
    tech-lessons.in © 2020 / Powered by  <a class="font-bold" target="_blank" href="https://gohugo.io/">Hugo</a>
    
  </span>

  <span onclick="window.scrollTo({top: 0, behavior: 'smooth'})" class="p-1 cursor-pointer">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5"
      stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M18 15l-6 -6l-6 6h12" />
    </svg>
  </span>
</footer>

<div class="search-ui absolute top-0 left-0 w-full h-full bg-white dark:bg-gray-800 hidden">
  <div class="container max-w-3xl mx-auto p-12">
    <div class="relative">
      <div class="my-4 text-center text-2xl font-bold">Search</div>

      <span class="p-2 absolute right-0 top-0 cursor-pointer close-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </svg>
      </span>
    </div>

    <input type="search" class="py-2 px-3 w-full dark:text-black border dark:border-transparent"
      placeholder="Enter search query" />

    <div class="search-results text-lg font-medium my-4 hidden">Results</div>
    <ul class="search-list my-2">

    </ul>

    <div class="no-results text-center my-8 hidden">
      <div class="text-xl font-semibold mb-2">No results found</div>
      <p class="font-light text-sm">Try adjusting your search query</p>
    </div>
  </div>
</div>





<script src="//localhost:1313/js/scripts.min.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9KKTKFQ2CM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9KKTKFQ2CM');
        }
      </script>





<script>
  const mobileMenuButton = document.querySelector('.mobile-menu-button')
  const mobileMenu = document.querySelector('.mobile-menu')
  function toggleMenu() {
    mobileMenu.classList.toggle('hidden');
    mobileMenu.classList.toggle('flex');
  }
  if(mobileMenu && mobileMenuButton){
    mobileMenuButton.addEventListener('click', toggleMenu)
  }
</script>
</body>
</html>
