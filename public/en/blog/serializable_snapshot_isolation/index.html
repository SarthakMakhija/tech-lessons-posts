<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" href="/favicon.png">

  <title>
  A guide to Serializable Snapshot Isolation in Key/Value storage engine - tech-lessons.in
  </title>
  <meta name="description" content=" Ensuring data consistency in the face of concurrent transactions is a critical challenge in database management. This article explores Serializable Snapshot Isolation (SSI) that promises the best of both worlds: strong data consistency without sacrificing performance. The article delves into the inner workings of SSI and explore its implementation for a Key/Value storage engine. " />
  <meta name="author" content="Sarthak Makhija" />
  
     <meta property="og:image" content="/serializable-snapshot-isolation.webp" />
  <meta name="generator" content="Hugo 0.140.1"><link rel="stylesheet" href="/css/styles.css" />

  
  

  <meta property="og:url" content="//localhost:1313/en/blog/serializable_snapshot_isolation/">
  <meta property="og:site_name" content="tech-lessons.in">
  <meta property="og:title" content="A guide to Serializable Snapshot Isolation in Key/Value storage engine">
  <meta property="og:description" content="Ensuring data consistency in the face of concurrent transactions is a critical challenge in database management. This article explores Serializable Snapshot Isolation (SSI) that promises the best of both worlds: strong data consistency without sacrificing performance. The article delves into the inner workings of SSI and explore its implementation for a Key/Value storage engine.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2024-03-22T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-03-22T00:00:00+00:00">
    <meta property="article:tag" content="Golang">
    <meta property="article:tag" content="Transaction">
    <meta property="article:tag" content="Isolation">
    <meta property="article:tag" content="Serializable Snapshot Isolation">
    <meta property="article:tag" content="BadgerDb">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="A guide to Serializable Snapshot Isolation in Key/Value storage engine">
  <meta name="twitter:description" content="Ensuring data consistency in the face of concurrent transactions is a critical challenge in database management. This article explores Serializable Snapshot Isolation (SSI) that promises the best of both worlds: strong data consistency without sacrificing performance. The article delves into the inner workings of SSI and explore its implementation for a Key/Value storage engine.">

  
  <meta itemprop="name" content="A guide to Serializable Snapshot Isolation in Key/Value storage engine">
  <meta itemprop="description" content="Ensuring data consistency in the face of concurrent transactions is a critical challenge in database management. This article explores Serializable Snapshot Isolation (SSI) that promises the best of both worlds: strong data consistency without sacrificing performance. The article delves into the inner workings of SSI and explore its implementation for a Key/Value storage engine.">
  <meta itemprop="datePublished" content="2024-03-22T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-03-22T00:00:00+00:00">
  <meta itemprop="wordCount" content="4575">
  <meta itemprop="keywords" content="Golang,Transaction,Isolation,Serializable Snapshot Isolation,BadgerDb">

  
</head>
<body class="dark:bg-gray-800 dark:text-white relative flex flex-col min-h-screen"><header class="container flex justify-between md:justify-between gap-4 flex-wrap p-6 mx-auto relative">
  <a href="//localhost:1313/en/" class="capitalize font-extrabold text-2xl">
    
    <img src="/logo.png" alt="tech-lessons.in" class="h-8 max-w-full" />
    
  </a>
  <button class="mobile-menu-button md:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <line x1="4" y1="8" x2="20" y2="8" />
      <line x1="4" y1="16" x2="20" y2="16" />
    </svg>
  </button>
  <ul class="mobile-menu absolute z-10 px-6 pb-6 md:p-0 top-full left-0 w-full md:w-auto md:relative hidden md:flex flex-col md:flex-row items-end md:items-center gap-4 lg:gap-6 bg-white dark:bg-gray-800">

    
    <li><a href="/en/">Home</a></li>
    
    <li><a href="/en/blog">Blogs</a></li>
    
    <li><a href="/en/page/about/">About Me</a></li>
    
    <li><a href="/en/page/projects/">My projects</a></li>
    

    

    
    <li class="grid place-items-center">
      <span class="open-search inline-block cursor-pointer">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <circle cx="10" cy="10" r="7" />
          <line x1="21" y1="21" x2="15" y2="15" />
        </svg>
      </span>
    </li>
    

    
  </ul>
</header>
<main class="flex-1">
  
  

  
  <div class="relative max-w-5xl mx-auto px-4">
    <img src="/serializable-snapshot-isolation.webp" class="rounded-lg shadow-sm w-full object-contain" />
    
    <figcaption class="font-extralight text-xs"><i>Background by Lum3n on Pexels</i></figcaption>
    
    
    <div class="absolute top-4 right-8 rounded shadow bg-white text-gray-900 dark:bg-gray-900 dark:text-white px-2 py-0.5">
      
  
    March 22, 2024
  


    </div>
    
  </div>
  

  <article class="prose lg:prose-lg mx-auto my-8 dark:prose-dark px-4 max-w-5xl">

    <h1 class="text-2xl font-bold mb-2">A guide to Serializable Snapshot Isolation in Key/Value storage engine</h1>
    
    <h5 class="text-sm flex items-center flex-wrap">
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <rect x="4" y="5" width="16" height="16" rx="2" />
        <line x1="16" y1="3" x2="16" y2="7" />
        <line x1="8" y1="3" x2="8" y2="7" />
        <line x1="4" y1="11" x2="20" y2="11" />
        <rect x="8" y="15" width="2" height="2" />
      </svg>
      Posted on 
  
    March 22, 2024
  


      
        &nbsp;&bull;&nbsp;
      
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <circle cx="12" cy="12" r="9" />
        <polyline points="12 7 12 12 15 15" />
      </svg>
      22&nbsp;minutes
      &nbsp;&bull;
      <svg xmlns="http://www.w3.org/2000/svg" class="mx-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <path d="M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <path d="M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <line x1="3" y1="6" x2="3" y2="19" />
        <line x1="12" y1="6" x2="12" y2="19" />
        <line x1="21" y1="6" x2="21" y2="19" />
      </svg>
      4575&nbsp;words
      
    </h5>
    

    <details id="TableOfContents" class="px-4 mt-4 bg-gray-100 dark:bg-gray-700 rounded toc">
    <summary class="flex items-center font-bold py-2 px-4 cursor-pointer justify-between select-none text-black dark:text-white">
      <span>Table of contents</span>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <polyline points="6 9 12 15 18 9"></polyline>
     </svg>
    </summary>

    <ul class="mt-2 pb-4">
        

        
        <li>
        <a href="#introduction">Introduction</a>
        

        
        </li><li>
        <a href="#understanding-snapshot-isolation">Understanding Snapshot isolation</a>
        

        
        <ul>
            <li>
        <a href="#anomalies">Anomalies</a>
        

        
        </li><li>
        <a href="#write-skew">Write skew</a>
        

        
        </li></ul>
      </li><li>
        <a href="#understanding-serializable-snapshot-isolation">Understanding Serializable Snapshot isolation</a>
        

        
        </li><li>
        <a href="#skiplist-and-mvcc">SkipList and MVCC</a>
        

        
        </li><li>
        <a href="#implementing-serializable-snapshot-isolation-in-a-keyvalue-store">Implementing Serializable Snapshot isolation in a Key/Value store</a>
        

        
        <ul>
            <li>
        <a href="#introduction-1">Introduction</a>
        

        
        </li><li>
        <a href="#implementing-readonlytransaction">Implementing ReadonlyTransaction</a>
        

        
        </li><li>
        <a href="#implementing-readwritetransaction">Implementing ReadWriteTransaction</a>
        

        
        </li><li>
        <a href="#putorupdate">PutOrUpdate</a>
        

        
        </li><li>
        <a href="#commit">Commit</a>
        

        
        </li><li>
        <a href="#get">Get</a>
        

        
        </li><li>
        <a href="#implementing-transactionexecutor">Implementing TransactionExecutor</a>
        

        
        </li><li>
        <a href="#implementing-transactiontimestampmark">Implementing TransactionTimestampMark</a>
        

        
        </li></ul>
      </li><li>
        <a href="#mentions">Mentions</a>
        

        
        </li><li>
        <a href="#references">References</a>
        </li></ul>
  </details>

    <p>Ensuring data consistency in the face of concurrent transactions is a critical challenge in database management.
Traditional serializable isolation, while guaranteeing data integrity, often suffers from performance bottlenecks due to extensive locking.
This article explores Serializable Snapshot Isolation (SSI) that promises the best of both worlds:
strong data consistency without sacrificing performance.
The article delves into the inner workings of SSI and explore its implementation for a Key/Value storage engine. I will refer to the research
paper titled <a href="https://dl.acm.org/doi/10.1145/2168836.2168853" target="_blank" rel="noopener">A critique of snapshot isolation</a>
.</p>
<h3 id="introduction">Introduction</h3>
<p>We will start by defining a few terms.</p>
<ul>
<li><strong>Transaction</strong>: is an atomic unit of work. A database transaction may involve writes to multiple tables, or multiple writes to a single table or maybe
multiple writes to multiple tables. In a Key/Value storage engine, the transaction pseudo-code would look like:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>transaction <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewReadWriteTransaction</span>().<span style="color:#50fa7b">Begin</span>()
</span></span><span style="display:flex;"><span>transaction.<span style="color:#50fa7b">Put</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;KeyValueStore&#34;</span>), []<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;BadgerDb&#34;</span>))
</span></span><span style="display:flex;"><span>transaction.<span style="color:#50fa7b">Put</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;StoreType&#34;</span>), []<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;LSM&#34;</span>))
</span></span><span style="display:flex;"><span>transaction.<span style="color:#50fa7b">Delete</span>([]<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;DiskType&#34;</span>))
</span></span><span style="display:flex;"><span>transaction.<span style="color:#50fa7b">Commit</span>()
</span></span></code></pre></div><p>The code snippet creates an instance of a pseudo <code>ReadWriteTransaction</code>, <code>puts</code> a couple of key/value pairs, <code>deletes</code> a key and then <code>commits</code> the transaction.
By definition, a transaction is atomic, which means all these actions will take place as a unit or none of them will take place.</p>
<ul>
<li>
<p><strong>Isolation</strong>: defines the behavior of the system in presence of other concurrent transactions. A system that provides <em>Serial</em> transaction isolation
ensures that all the transactions run serially - one after the other. Imagine that you are building a transactional Key/Value storage engine. The kind
of questions that you will ask while implementing transaction isolation would include:</p>
<ul>
<li>What happens when two transactions write to the same key at the same time?</li>
<li>What happens when a transaction attempts to read the value of a key, which is being written to by another transaction?</li>
<li>Can a readonly transaction abort?</li>
</ul>
</li>
<li>
<p><strong>Snapshot isolation</strong>: the snapshot from which a transaction reads is not affected by concurrently running transactions. To support snapshot isolation,
databases and Key/Value storage engines maintain multiple versions of the data. Anytime a transaction begins, it  is given a <code>beginTimestamp</code> and
if a transaction commits without any conflict, it is given a <code>commitTimestamp</code>. A transaction <strong>txn<sub>(i)</sub></strong> with a begin timestamp of
<strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong> reads the latest version of data (/key) with the commit timestamp <strong>C</strong> <strong>&lt;</strong> <strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong>.
Two concurrent transactions can still conflict if there is a <strong>write-write</strong> conflict, meaning, two transactions writing to the same key (in a Key/Value storage engine).</p>
</li>
<li>
<p><strong>Serializable Snapshot isolation</strong>: the snapshot from which a transaction reads is not affected by concurrently running transactions. The core
idea of maintaining multiple versions of data remains the same. Two concurrent transactions can still conflict if
there is a <strong>read-write</strong> conflict,</p>
</li>
<li>
<p><strong>MVCC</strong>: stands for multi-version concurrency control. It is the backbone for implementing transactions with Snapshot or
Serializable Snapshot isolation. In a multi-versioned Key/Value storage engine, each key is given a version which is incremented every time a write
happens in the storage engine. The following visual should help in building a light mind-map of a read/write transaction flow in a Key/Value storage
engine that supports MVCC with Serializable Snapshot isolation.</p>
</li>
</ul>
<div class="align-center-exclude-width-change">
    <img src="/transaction_flow_mvcc.webp" alt="Transaction Flow with MVCC"/>
</div>
<p>The flow can be summarized as:</p>
<ul>
<li>Create an instance of <code>ReadWriteTransaction</code> and use it to perform relevant operations.</li>
<li><code>Commit</code> the transaction.</li>
<li>When the transaction is committed, generate <code>CommitTimestamp</code>. (<code>CommitTimestamp</code> serves as the version for all the keys in the MVCC store).
If there is no <strong>read-write</strong> conflict, the timestamp will be generated for the transaction.</li>
<li>Update all the keys in the transaction with the generated <code>CommitTimestamp</code>.</li>
<li>Serially apply all the transactions to the state machine of the Key/Value storage engine.</li>
</ul>
<p>Let&rsquo;s go a little deeper into Snapshot isolation.</p>
<h3 id="understanding-snapshot-isolation">Understanding Snapshot isolation</h3>
<p>In <strong>Snapshot isolation</strong>, the snapshot from which a transaction reads is not affected by concurrently running transactions. To support snapshot isolation,
databases and Key/Value storage engines maintain <a href="#skiplist-and-mvcc">multiple versions of the data</a>
.</p>
<p>The high-level implementation of <code>Get</code> in <strong>Snapshot isolation</strong>, in a Key/Value storage engine can be summarized as:</p>
<ul>
<li>Each transaction is given a <code>beginTimestamp</code>. It is an increasing number.</li>
<li>Timestamps are assigned by a centralized authority called <code>Oracle</code> (or <code>Timestamp Oracle</code>).</li>
<li>A transaction <strong>txn<sub>(i)</sub></strong> with a begin timestamp of <strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong> reads the latest version of keys
with the commit timestamp <strong>C</strong> <strong>&lt;</strong> <strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong>.</li>
<li>Simply put, a transaction <strong>txn<sub>(i)</sub></strong> observes all the changes that have been committed before the start of <strong>txn<sub>(i)</sub></strong>.</li>
</ul>
<p>Before we explore the intricacies of <code>Oracle</code> implementation, let&rsquo;s briefly examine the <code>beginTimestamp</code> method.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Oracle <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    lock            sync.Mutex
</span></span><span style="display:flex;"><span>    nextTimestamp   <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//other fields omitted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewOracle</span>() <span style="color:#ff79c6">*</span>Oracle {
</span></span><span style="display:flex;"><span>  oracle <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>Oracle{
</span></span><span style="display:flex;"><span>    nextTimestamp: <span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> oracle
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (oracle <span style="color:#ff79c6">*</span>Oracle) <span style="color:#50fa7b">beginTimestamp</span>() <span style="color:#8be9fd">uint64</span> {
</span></span><span style="display:flex;"><span>    oracle.lock.<span style="color:#50fa7b">Lock</span>()
</span></span><span style="display:flex;"><span>    beginTimestamp <span style="color:#ff79c6">:=</span> oracle.nextTimestamp <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    oracle.lock.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//code omitted
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">return</span> beginTimestamp
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Every transaction gets a <code>beginTimestamp</code> which is represented as <code>uint64</code> (64 bits).
The <code>nextTimestamp</code> field of <code>Oracle</code> denotes the <code>commitTimestamp</code> that shall be given to the next ready-to-commit transaction. Based on the field <code>nextTimestamp</code>, we can derive the <code>beginTimestamp</code>.</p>
<ul>
<li>If the <code>nextTimestamp</code> is 10, the next transaction that is ready to commit will be given 10 as its <code>commitTimestamp</code>.</li>
<li>This means 9 is the latest <code>commitTimestamp</code> that is given to some transaction <strong>txn<sub>(some)</sub></strong>.</li>
<li>This means that the current transaction <strong>txn<sub>(current)</sub></strong> can be awarded 9 as its <code>beginTimestamp</code>.</li>
<li>So, <code>beginTimestamp = nextTimestamp - 1</code>.</li>
<li>Simply put, <strong>txn<sub>(current)</sub></strong> can read keys with <code>commitTimestamp</code> &lt; 9, where 9 is the <code>beginTimestamp</code> of <strong>txn<sub>(current)</sub></strong>.</li>
</ul>
<p>A <code>ReadWriteTransaction</code> is assigned a <code>commitTimestamp</code> when it is ready to commit. Before assigning the <code>commitTimestamp</code>, it is necessary to
check that there are no <em>write-write</em> conflicts. Two concurrent transactions can conflict in Snapshot isolation if:</p>
<ol>
<li>Both the transactions <strong>txn<sub>(i)</sub></strong> and <strong>txn<sub>(j)</sub></strong> write to the same key called <em>Spatial overlap</em>, and</li>
<li>Both the transaction have a <em>Temporal Overlap</em>. <strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong> <code>&lt;</code> <strong>T<sub>c</sub>(txn<sub>(j)</sub>)</strong> and <strong>T<sub>b</sub>(txn<sub>(j)</sub>)</strong> <code>&lt;</code> <strong>T<sub>c</sub>(txn<sub>(i)</sub>)</strong>,
where <strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong> represents the <code>beginTimestamp</code> of <strong>txn<sub>(i)</sub></strong>, <strong>T<sub>c</sub>(txn<sub>(i)</sub>)</strong> represents
the <code>commitTimestamp</code> of <strong>txn<sub>(i)</sub></strong>,<strong>T<sub>b</sub>(txn<sub>(j)</sub>)</strong> represents the <code>beginTimestamp</code> of <strong>txn<sub>(j)</sub></strong>,
<strong>T<sub>c</sub>(txn<sub>(j)</sub>)</strong> represents the <code>commitTimestamp</code> of <strong>txn<sub>(j)</sub></strong>.</li>
</ol>
<p>Let&rsquo;s write the pseudo-code for committing a transaction <strong>txn<sub>(i)</sub></strong> with <code>beginTimestamp</code> as <strong>T<sub>b</sub></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#6272a4">## detect conflict</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> each key in keysToCommit:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> lastCommit<span style="color:#ff79c6">(</span>key<span style="color:#ff79c6">)</span> &gt; txn.beginTimestamp<span style="color:#ff79c6">()</span>
</span></span><span style="display:flex;"><span>	    abort;
</span></span><span style="display:flex;"><span>    end <span style="color:#ff79c6">if</span>;
</span></span><span style="display:flex;"><span>end <span style="color:#ff79c6">for</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">## prepare for commit</span>
</span></span><span style="display:flex;"><span>commitTimestamp &lt;- oracle.commitTimestamp<span style="color:#ff79c6">()</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> each key in keysToCommit:
</span></span><span style="display:flex;"><span>   lastCommit<span style="color:#ff79c6">(</span>key<span style="color:#ff79c6">)</span> &lt;- commitTimestamp
</span></span><span style="display:flex;"><span>end <span style="color:#ff79c6">for</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">## apply commits</span>
</span></span></code></pre></div><p>The pseudo-code checks for:</p>
<ul>
<li>spatial overlap, and</li>
<li>only the first part of temporal overlap condition. If a newer commit exists for any key that the transaction is going to write such that, <code>lastCommit(key) &gt; txn.beginTimestamp()</code>,
the transaction is aborted. This ensures that the transaction only operates on data that reflects the state at the start of the transaction,
preventing inconsistencies caused by concurrent modifications.</li>
</ul>
<p>Snapshot isolation prevents a lot of anomalies.</p>
<h4 id="anomalies">Anomalies</h4>
<div class="align-center-exclude-width-change">
    <img src="/snapshot-isolation-anomalies.webp" alt="Anomalies prevented by Snapshot isolation"/>
    <figcaption class="figcaption text-sm">
        Snapshot Isolation prevents many anomalies but not write skew.
    </figcaption>
    <figcaption class="text-sm">
        The definition of these anomalies is from the research paper: <a href="https://dl.acm.org/doi/10.1145/2168836.2168853">A critique of snapshot isolation</a>.
        Question mark image is from <a href="https://pixabay.com/vectors/question-mark-thinking-question-5656992/">Pixabay</a>
    </figcaption>
</div>
<h4 id="write-skew">Write skew</h4>
<p>Two concurrent transactions can conflict in Snapshot isolation if they write to the same key and there is a temporal overlap.
But, what if two transactions write to different keys which are related by some constraint.</p>
<p>Consider the following state in a Key/Value storage engine:</p>
<ul>
<li>two keys <code>x</code> and <code>y</code> with initial values as 1 and related by the constraint <code>x + y &gt; 0</code>.</li>
<li>two concurrent transactions, <strong>txn<sub>(x)</sub></strong> and <strong>txn<sub>(y)</sub></strong>, both of which get a <code>beginTimestamp</code> of 1, read the
values of <code>x</code> and <code>y</code> and get 1 as the value for each key.</li>
<li><strong>txn<sub>(x)</sub></strong> reduces the value of <code>x</code> by 1 and <strong>txn<sub>(y)</sub></strong> reduces the value of <code>y</code> by 1.</li>
</ul>
<p>The following events highlight an anomaly called <em>write skew</em>.</p>
<ul>
<li>The transaction <strong>txn<sub>(x)</sub></strong> gets a <code>commitTimestamp</code> of 2, checks that <code>x + y &gt; 0</code>, reduces the value of <code>x</code> by 1 and
writes the versioned value of <code>x</code> back to the store. At version 2, <code>x</code> becomes 0.</li>
<li>The transaction <strong>txn<sub>(y)</sub></strong> gets a <code>commitTimestamp</code> of 3, checks that <code>x + y &gt; 0</code>, [[it will read the values of x and y using its <code>beginTimestamp</code>]]
reduces the value of <code>y</code> by 1 and writes the versioned value of <code>y</code> back to the store. At version 3, <code>y</code> becomes 0.</li>
<li>Another readonly transaction <strong>txn<sub>(another)</sub></strong> starts at a later point in time, gets a <code>beginTimestamp</code> of 6 and reads the values of <code>x</code> and <code>y</code>:
<ul>
<li>reads the latest value of <code>x</code> such that the <code>commitTimestamp</code> of <code>x</code> <code>&lt;</code> 6. It gets <code>x = 0</code>. [<code>x</code> became 0 at version 2]</li>
<li>reads the latest value of <code>y</code> such that the <code>commitTimestamp</code> of <code>y</code> <code>&lt;</code> 6. It gets <code>y = 0</code>. [<code>y</code> became 0 at version 3]</li>
</ul>
</li>
</ul>
<p>The constraint <code>x + y &gt; 0</code> is broken. Snapshot isolation does not prevent write skew.</p>
<blockquote>
<p>Storage systems like Percolator, <a href="https://github.com/dgraph-io/dgraph" target="_blank" rel="noopener">Dgraph</a>
 implement Snapshot isolation.</p>
</blockquote>
<p>Let&rsquo;s now move onto Serializable Snapshot isolation, which prevents write-skew.</p>
<h3 id="understanding-serializable-snapshot-isolation">Understanding Serializable Snapshot isolation</h3>
<p>Serializable Snapshot isolation derives the ideas of <code>beginTimestamp</code>, <code>commitTimestamp</code> and <code>Oracle</code> from Snapshot isolation. The difference is the
way conflict is detected between two concurrently running transactions.</p>
<p>A transaction <strong>txn<sub>(j)</sub></strong> conflicts with another transaction <strong>txn<sub>(i)</sub></strong>, if:</p>
<ol>
<li><strong>txn<sub>(j)</sub></strong> writes to the keys read by <strong>txn<sub>(i)</sub></strong>, and</li>
<li><strong>txn<sub>(j)</sub></strong> commits during the lifetime of <strong>txn<sub>(i)</sub></strong>, <strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong> <code>&lt;</code> <strong>T<sub>c</sub>(txn<sub>(j)</sub>)</strong> &lt; <strong>T<sub>c</sub>(txn<sub>(i)</sub>)</strong>.</li>
</ol>
<p>Here, <strong>T<sub>b</sub>(txn<sub>(i)</sub>)</strong> represents the <code>beginTimestamp</code> of the transaction <strong>txn<sub>(i)</sub></strong>,
<strong>T<sub>c</sub>(txn<sub>(i)</sub>)</strong> represents the <code>commitTimestamp</code> of the transaction <strong>txn<sub>(i)</sub></strong> and
<strong>T<sub>c</sub>(txn<sub>(j)</sub>)</strong> represents the <code>commitTimestamp</code> of the transaction <strong>txn<sub>(j)</sub></strong>.</p>
<p>Let&rsquo;s write the pseudo-code for committing a transaction <strong>txn<sub>(i)</sub></strong> with <code>beginTimestamp</code> as <strong>T<sub>b</sub></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#6272a4">## detect conflict</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> each key in keysRead:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> lastCommit<span style="color:#ff79c6">(</span>key<span style="color:#ff79c6">)</span> &gt; txn.beginTimestamp<span style="color:#ff79c6">()</span>
</span></span><span style="display:flex;"><span>	    abort;
</span></span><span style="display:flex;"><span>    end <span style="color:#ff79c6">if</span>;
</span></span><span style="display:flex;"><span>end <span style="color:#ff79c6">for</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">## prepare for commit</span>
</span></span><span style="display:flex;"><span>commitTimestamp &lt;- oracle.commitTimestamp<span style="color:#ff79c6">()</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> each key in keysToCommit:
</span></span><span style="display:flex;"><span>   lastCommit<span style="color:#ff79c6">(</span>key<span style="color:#ff79c6">)</span> &lt;- commitTimestamp
</span></span><span style="display:flex;"><span>end <span style="color:#ff79c6">for</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">## apply commits</span>
</span></span></code></pre></div><p>The pseudo-code checks to see that none of the <strong>keys read by the transaction</strong> <strong>txn<sub>(i)</sub></strong> have been committed after it began.
The implementation of Serializable Snapshot isolation will require each read-write transaction to keep track of the read keys.</p>
<blockquote>
<p><a href="https://github.com/dgraph-io/badger" target="_blank" rel="noopener">BadgerDb</a>
 implements Serializable Snapshot isolation.</p>
</blockquote>
<p>Before diving into the implementation of Serializable Snapshot isolation, let&rsquo;s quickly take a look at SkipList and MVCC.</p>
<h3 id="skiplist-and-mvcc">SkipList and MVCC</h3>
<p>A SkipList is a layered data structure where the lowest layer is an ordinary <strong>ordered</strong> linked list. Each higher layer acts as an
&ldquo;express lane&rdquo; for the lists below. Searching proceeds downwards from the top until consecutive elements bracketing the search element are found.</p>
<p>SkipList can be represented with the following structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> SkipList <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	header <span style="color:#ff79c6">*</span>SkiplistNode
</span></span><span style="display:flex;"><span>	maxLevel  <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> SkiplistNode <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	key      <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>	value    <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>	forwards []<span style="color:#ff79c6">*</span>SkiplistNode
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The struct <code>SkipList</code> contains a pointer to a header node and each <code>SkiplistNode</code> contains a key/value pair along with a slice of forward pointers.
The header node is the starting node for all the read/write operations and all the key/value pairs will be added to its right.</p>
<p>One way to ensure that all the key/value pairs are added to the right is to create a header node with some sentinel key/value pair when SkipList is
instantiated. If we are creating a SkipList to store positive keys, then the sentinel key in the header node can be -1.
Similarly, if we are creating a SkipList to store string keys, then the sentinel value for the key in the header node can be blank.</p>
<blockquote>
<p>We are using keys and values of type <code>int</code> only to serve as example.</p>
</blockquote>
<div class="align-center-exclude-width-change">
    <img src="/skiplist.png" alt="Transaction Flow with MVCC"/>
</div>
<p>The above image is the representation of our <code>SkipList</code> struct.</p>
<blockquote>
<p><code>(10, 100)</code>, <code>(20, 200)</code> represent key,value pairs.</p>
</blockquote>
<p>Let&rsquo;s say we want to search the key 25. The following will be the approach:</p>
<ol>
<li>Start with the header node at the highest level and keep moving towards the right until the right key is greater than the search key.</li>
<li>Right of the header node, at the highest level is 10 which is less than 25, so move right.</li>
<li>Now we are on the node containing the key 10.</li>
<li>Right of the node containing key 10 is 60 (at the highest level), which is greater than 25. So move to the lower level on the
same node. Keep moving down until the right node contains a key that is less than or equal to the search key.</li>
<li>We will get down to the level 1 (index starting from 0) on the node containing key 10. Right of this level contains 20, so move right.</li>
<li>Now we are on the node containing the key 20.</li>
<li>Right of the node containing key 20 is 30 which is greater than the search key. So move to the lower level on the same node.</li>
<li>Right of level 0 on the node containing key 20 is still 30. There are no more levels to go down to.</li>
<li>So, we can conclude that the key 25 is not present in the list.</li>
</ol>
<p>SkipList is a good data structure in a sense that it allows us to store multiple versions of each key (in a Key/Value storage engine).
Each key is given a version, which is usually the <code>commitTimestamp</code> in Snapshot and Serializable Snapshot isolation.
Each node of SkipList now stores an instance of <code>VersionedKey</code> that can be represented as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> VersionedKey <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	key     []<span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>	version <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (versionedKey VersionedKey) <span style="color:#50fa7b">compare</span>(other VersionedKey) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    comparisonResult <span style="color:#ff79c6">:=</span> bytes.<span style="color:#50fa7b">Compare</span>(versionedKey.<span style="color:#50fa7b">getKey</span>(), other.<span style="color:#50fa7b">getKey</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> comparisonResult <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        thisVersion, otherVersion <span style="color:#ff79c6">:=</span> versionedKey.<span style="color:#50fa7b">getVersion</span>(), other.<span style="color:#50fa7b">getVersion</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> thisVersion <span style="color:#ff79c6">==</span> otherVersion {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> thisVersion &lt; otherVersion {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> comparisonResult
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>Get</code> method in <code>SkiplistNode</code> takes a <code>VersionedKey</code>, that combines the target key the user wants to search along with the <code>beginTimestamp</code> of the transaction. The method <code>Get</code>
uses the algorithm described earlier. The code is available <a href="https://github.com/SarthakMakhija/serialized-snapshot-isolation/blob/main/mvcc/SkiplistNode.go" target="_blank" rel="noopener">here</a>
.</p>
<p>We have covered all the building blocks of Serialized Snapshot isolation. It is time to implement it.</p>
<h3 id="implementing-serializable-snapshot-isolation-in-a-keyvalue-store">Implementing Serializable Snapshot isolation in a Key/Value store</h3>
<p>This article describes an <a href="https://github.com/SarthakMakhija/serialized-snapshot-isolation" target="_blank" rel="noopener">implementation</a>
 of Serialized Snapshot isolation
that was implemented with <a href="https://github.com/dgraph-io/badger/" target="_blank" rel="noopener">BadgerDb</a>
 as reference. This implementation focuses specifically on the <em>isolation</em> property of transactions.</p>
<h4 id="introduction-1">Introduction</h4>
<p>Let me start by introducing core concepts in the code.</p>
<ol>
<li><strong>ReadonlyTransaction</strong>: provides support for <code>Get</code> method. A <code>ReadonlyTransaction</code> never aborts.</li>
<li><strong>ReadWriteTransaction</strong>: provides support for <code>PutOrUpdate</code>, <code>Get</code> and <code>Commit</code> methods. A <code>ReadWriteTransaction</code> can abort if there is a Read-Write conflict with another transaction.</li>
<li><strong>Oracle</strong>: awards <code>beginTimestamp</code> and <code>commitTimestamp</code> to transactions. It also checks for conflicts between <code>ReadWriteTransaction</code>(s).</li>
<li><strong>TransactionExecutor</strong>: applies transactions serially, one after the other.</li>
<li><strong>TransactionTimestampMark</strong>: keeps track of the timestamps that are processed. These could be <code>beginTimestamp</code> or <code>commitTimestamp</code>.</li>
<li><strong>MemTable</strong>: an in-memory data structure that uses <a href="#skiplist-and-mvcc">SkipList</a>
 for storing versioned keys. It acts as the state machine.</li>
</ol>
<p>Let&rsquo;s start by implementing <code>ReadonlyTransaction</code>.</p>
<h4 id="implementing-readonlytransaction">Implementing ReadonlyTransaction</h4>
<p><code>ReadonlyTransaction</code> provides <code>Get</code> method that fetches the value for the given key from the state machine.</p>
<p>Let&rsquo;s take a look at the definition or <code>ReadonlyTransaction</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> ReadonlyTransaction <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	beginTimestamp <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>	memtable       <span style="color:#ff79c6">*</span>mvcc.MemTable
</span></span><span style="display:flex;"><span>	oracle         <span style="color:#ff79c6">*</span>Oracle
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A <code>ReadonlyTransaction</code> has a <code>beginTimestamp</code> which is obtained from <code>Oracle</code> and an instance of <code>MemTable</code> to fetch the value for a key.</p>
<p>Anytime a new instance of <code>ReadonlyTransaction</code> is created, we get the <code>beginTimestamp</code> from <code>Oracle</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewReadonlyTransaction</span>(oracle <span style="color:#ff79c6">*</span>Oracle) <span style="color:#ff79c6">*</span>ReadonlyTransaction {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>ReadonlyTransaction{
</span></span><span style="display:flex;"><span>    beginTimestamp: oracle.<span style="color:#50fa7b">beginTimestamp</span>(),
</span></span><span style="display:flex;"><span>    oracle:         oracle,
</span></span><span style="display:flex;"><span>    memtable:       oracle.transactionExecutor.memtable,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s take a look the complete implementation of the <code>beginTimetamp</code> method of <code>Oracle</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (oracle <span style="color:#ff79c6">*</span>Oracle) <span style="color:#50fa7b">beginTimestamp</span>() <span style="color:#8be9fd">uint64</span> {
</span></span><span style="display:flex;"><span>	oracle.lock.<span style="color:#50fa7b">Lock</span>()
</span></span><span style="display:flex;"><span>	beginTimestamp <span style="color:#ff79c6">:=</span> oracle.nextTimestamp <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>	oracle.beginTimestampMark.<span style="color:#50fa7b">Begin</span>(beginTimestamp)
</span></span><span style="display:flex;"><span>	oracle.lock.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_ = oracle.commitTimestampMark.<span style="color:#50fa7b">WaitForMark</span>(context.<span style="color:#50fa7b">Background</span>(), beginTimestamp)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> beginTimestamp
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>nextTimestamp</code> field of <code>Oracle</code> denotes the <code>commitTimestamp</code> that shall be given to the next ready-to-commit transaction.
Based on the field <code>nextTimestamp</code>, we can derive the <code>beginTimestamp</code>.</p>
<ul>
<li>If the <code>nextTimestamp</code> is 10, the next transaction that is ready to commit will be given 10 as its <code>commitTimestamp</code>.</li>
<li>This means that 9 is the latest timestamp that is given to some transaction <strong>txn<sub>(some)</sub></strong> as its <code>commitTimestamp</code>.</li>
<li>This means that the current transaction <strong>txn<sub>(current)</sub></strong> can be awarded 9 as its <code>beginTimestamp</code>.</li>
<li>So, <code>beginTimestamp = nextTimestamp - 1</code>.</li>
<li>Simply put, <strong>txn<sub>(current)</sub></strong> can read keys with <code>commitTimestamp</code> &lt; 9, where 9 is the <code>beginTimestamp</code> of <strong>txn<sub>(current)</sub></strong>.</li>
</ul>
<blockquote>
<p>If the <code>nextTimestamp</code> is 10, it means that 9 is the latest timestamp that is given to some transaction <strong>txn<sub>(some)</sub></strong> as its <code>commitTimestamp</code>.
Does this mean that the commits with timestamp 9 have been applied to the storage?</p>
<p>No, committing a transaction and actually applying its changes to the storage are two distinct events.
Committing essentially marks a transaction as ready to be applied, but it doesn&rsquo;t instantly reflect in the storage. Committed transactions with assigned commitTimestamps form a queue,
awaiting their turn to be applied to the storage in a serial manner. This means transactions are processed and reflected in the storage one after another, ensuring orderly updates.</p>
<p>Implementations like <a href="https://github.com/dgraph-io/badger/blob/6acc8e801739f6702b8d95f462b8d450b9a0455b/txn.go#L104" target="_blank" rel="noopener">BadgerDb</a>
 wait
till all the transactions upto the assigned <code>beginTimestamp</code> are applied.</p>
</blockquote>
<p>We will look at the <code>TransactionTimestampMark</code> later, but <code>oracle.commitTimestampMark.WaitForMark(...)</code> waits for all the commits till <code>beginTimetamp</code> to be applied to the state machine.</p>
<blockquote>
<p>Is waiting really necessary in getting <code>beginTimestamp</code>?
There are two options:</p>
<ol>
<li>
<p>Wait for a fixed timeout and allow all the commits till <code>beginTimestamp</code> to be applied to the state machine. This may increase the response time
for read operations.</p>
</li>
<li>
<p>Do not wait. This may result result in getting an old value for a key. Example,
if the <code>nextTimestamp</code> is 10, the current transaction will be awarded 9 as its <code>beginTimestamp</code>. However, there might be transactions in the queue
waiting to be applied to state machine. This means, reading the value for a key from the state machine will get the value with latest version (/timestamp)
which may be less than 9, it could be 6 or could be 5 or anything.</p>
</li>
</ol>
</blockquote>
<p>The <code>Get</code> method is fairly simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (transaction <span style="color:#ff79c6">*</span>ReadonlyTransaction) <span style="color:#50fa7b">Get</span>(key []<span style="color:#8be9fd">byte</span>) (mvcc.Value, <span style="color:#8be9fd">bool</span>) {
</span></span><span style="display:flex;"><span>	versionedKey <span style="color:#ff79c6">:=</span> mvcc.<span style="color:#50fa7b">NewVersionedKey</span>(key, transaction.beginTimestamp)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> transaction.memtable.<span style="color:#50fa7b">Get</span>(versionedKey)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It involves the following:</p>
<ol>
<li>Creating a new instance of <code>VersionedKey</code> that consists of the actual key and the <code>beginTimestamp</code> of the transaction.</li>
<li>Reading the value from the <code>MemTable</code>. This implementation uses <code>SkipList</code> as the in-memory data structure for storing versioned keys,
so the <code>Get</code> from <code>MemTable</code> follows the algorithm described <a href="#skiplist-and-mvcc">earlier</a>
.</li>
</ol>
<p>This implementation shows reading the value for a versioned key from an in-memory SkipList. The concept would remain the same even for implementing
a <code>Get</code> in a persistent <a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree" target="_blank" rel="noopener">LSM-tree</a>
 based Key/Value storage engine.
Each <code>ReadonlyTransaction</code> will get a <code>beginTimestamp</code> and instead of just reading from an in-memory MemTable, a read will be executed
from an active memtable, inactive memtable(s) and the increasing levels of SSTable.</p>
<h4 id="implementing-readwritetransaction">Implementing ReadWriteTransaction</h4>
<p>Let&rsquo;s look at the definition of <code>ReadWriteTransaction</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> ReadWriteTransaction <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	beginTimestamp <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>	batch          <span style="color:#ff79c6">*</span>Batch
</span></span><span style="display:flex;"><span>	reads          [][]<span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>	memtable       <span style="color:#ff79c6">*</span>mvcc.MemTable
</span></span><span style="display:flex;"><span>	oracle         <span style="color:#ff79c6">*</span>Oracle
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A <code>ReadWriteTransaction</code> has a <code>beginTimestamp</code> which is obtained from <code>Oracle</code> and an instance of <code>MemTable</code> to perform read/write from/to.</p>
<p>It also contains a pointer to an instance of <code>Batch</code> which maintains all the key/value pairs that are going to be updated
in one <code>ReadWriteTransaction</code>.
Every <code>ReadWriteTransaction</code> batches the changes and when the changes are ready to be committed, a <code>commitTimestamp</code> is obtained from <code>Oracle</code>
and the changes are applied serially to the state machine.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Batch <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	pairs []KeyValuePair
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Serializable Snapshot isolation checks for Read-Write conflict as explained <a href="#understanding-serializable-snapshot-isolation">earlier</a>
. In order to
facilitate conflict detection, each <code>ReadWriteTransaction</code> also holds a slice (/array, /arraylist) of read keys. The field <code>reads</code> denotes all the
keys read by a <code>ReadWriteTransaction</code>.</p>
<blockquote>
<p>BadgerDB uses Serializable Snapshot Isolation for transactions. During a transaction, BadgerDB stores a <a href="https://github.com/dgraph-io/badger/blob/6acc8e801739f6702b8d95f462b8d450b9a0455b/txn.go#L257" target="_blank" rel="noopener">fingerprint (like a hash)</a>

for each key it reads.
These fingerprints are 64-bit unsigned integers (uint64). There are two main reasons for using fingerprints instead of the actual keys:</p>
<ol>
<li>
<p>Reduced memory usage: Fingerprints are smaller than the original keys, saving memory within each transaction.</p>
</li>
<li>
<p>Faster comparisons: Comparing fingerprints (8 bytes) is quicker than comparing entire keys (which can vary in size).</p>
</li>
</ol>
<p>However, there&rsquo;s a potential downside. Since fingerprints are shorter than keys, it&rsquo;s possible for two different keys to have the
same fingerprint (collisions). This can lead to false conflicts between transactions.</p>
</blockquote>
<p>Anytime a new instance of <code>ReadWriteTransaction</code> is created, we get the <code>beginTimestamp</code> from <code>Oracle</code> amd we also create a new instance of <code>Batch</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewReadWriteTransaction</span>(oracle <span style="color:#ff79c6">*</span>Oracle) <span style="color:#ff79c6">*</span>ReadWriteTransaction {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>ReadWriteTransaction{
</span></span><span style="display:flex;"><span>		beginTimestamp: oracle.<span style="color:#50fa7b">beginTimestamp</span>(),
</span></span><span style="display:flex;"><span>		batch:          <span style="color:#50fa7b">NewBatch</span>(),
</span></span><span style="display:flex;"><span>		oracle:         oracle,
</span></span><span style="display:flex;"><span>		memtable:       oracle.transactionExecutor.memtable,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s take a look at the <code>PutOrUpdate</code> method.</p>
<h4 id="putorupdate">PutOrUpdate</h4>
<p>The idea is to batch all the distinct key/value pairs and commit them once the <code>Commit</code> method is invoked.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (transaction <span style="color:#ff79c6">*</span>ReadWriteTransaction) <span style="color:#50fa7b">PutOrUpdate</span>(key []<span style="color:#8be9fd">byte</span>, value []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>	err <span style="color:#ff79c6">:=</span> transaction.batch.<span style="color:#50fa7b">Add</span>(key, value)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (batch <span style="color:#ff79c6">*</span>Batch) <span style="color:#50fa7b">Add</span>(key, value []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> batch.<span style="color:#50fa7b">Contains</span>(key) {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> errors.DuplicateKeyInBatchErr
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  batch.pairs = <span style="color:#8be9fd;font-style:italic">append</span>(batch.pairs, <span style="color:#50fa7b">newKeyValuePair</span>(key, value))
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="commit">Commit</h4>
<p>Committing a transaction is a bit involved. Let&rsquo;s understand the steps involved:</p>
<ol>
<li>Attempt to generate the <code>commitTimestamp</code> for the transaction.
<ol>
<li>Detect conflict with other transactions.</li>
<li>If there is no conflict, generate the timestamp.</li>
<li>To detect conflict with other transactions, <code>Oracle</code> must keep a track of all the ready-to-commit transactions and clean it up in time.</li>
</ol>
</li>
<li>Convert the transaction&rsquo;s <code>Batch</code> to <code>TimestampedBatch</code>
<ol>
<li><code>TimestampedBatch</code> contains all the keys of the <code>Batch</code> with the <code>commitTimestamp</code> as the version</li>
</ol>
</li>
<li>Apply <code>TimestampedBatch</code> serially to the state machine.</li>
</ol>
<p>Let&rsquo;s look the <code>Commit</code> method provided by <code>ReadWriteTransaction</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (transaction <span style="color:#ff79c6">*</span>ReadWriteTransaction) <span style="color:#50fa7b">Commit</span>() (<span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> transaction.batch.<span style="color:#50fa7b">IsEmpty</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.EmptyTransactionErr
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//get the commitTimestamp, if there is no conflict.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	commitTimestamp, err <span style="color:#ff79c6">:=</span> transaction.oracle.<span style="color:#50fa7b">mayBeCommitTimestampFor</span>(transaction)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	commitCallback <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		transaction.oracle.commitTimestampMark.<span style="color:#50fa7b">Finish</span>(commitTimestamp)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//convert the batch to a timestampedBatch: use commitTimestamp in all the keys of the Batch.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	timestampedBatch <span style="color:#ff79c6">:=</span> transaction.batch.<span style="color:#50fa7b">ToTimestampedBatch</span>(commitTimestamp, commitCallback)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//apply timestampedBatch serially.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">return</span> transaction.oracle.transactionExecutor.<span style="color:#50fa7b">Submit</span>(timestampedBatch), <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>Commit</code> method attempts to generate the <code>commitTimestamp</code> buy invoking the method <code>mayBeCommitTimestampFor</code>. Let&rsquo;s take a look.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (oracle <span style="color:#ff79c6">*</span>Oracle) <span style="color:#50fa7b">mayBeCommitTimestampFor</span>(transaction <span style="color:#ff79c6">*</span>ReadWriteTransaction) (<span style="color:#8be9fd">uint64</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	oracle.lock.<span style="color:#50fa7b">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> oracle.lock.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//check for conflict.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> oracle.<span style="color:#50fa7b">hasConflictFor</span>(transaction) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>, txnErrors.ConflictErr
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	oracle.<span style="color:#50fa7b">finishBeginTimestampForReadWriteTransaction</span>(transaction)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//clean up the committedTransactions.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	oracle.<span style="color:#50fa7b">cleanupCommittedTransactions</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//generate next commitTimestamp.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	commitTimestamp <span style="color:#ff79c6">:=</span> oracle.nextTimestamp
</span></span><span style="display:flex;"><span>	oracle.nextTimestamp = oracle.nextTimestamp <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//mark the current transaction as ready to commit and track it in the committedTransactions.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	oracle.<span style="color:#50fa7b">trackReadyToCommitTransaction</span>(transaction, commitTimestamp)
</span></span><span style="display:flex;"><span>	oracle.commitTimestampMark.<span style="color:#50fa7b">Begin</span>(commitTimestamp)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> commitTimestamp, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The idea behind <code>mayBeCommitTimestampFor</code> can be summarized as:</p>
<ol>
<li>Detect conflict with other transactions and return an error if there is a conflict.</li>
<li>Clean up the ready-to-commit state.</li>
<li>Generate the <code>commitTimestamp</code>.</li>
<li>Track the current transaction as ready-to-commit.</li>
<li>Return the <code>commitTimestamp</code>.</li>
</ol>
<p>The code for determining conflicts checks to see if there is a read-write conflict between the current transaction and any other
ready-to-commit transaction.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (oracle <span style="color:#ff79c6">*</span>Oracle) <span style="color:#50fa7b">hasConflictFor</span>(transaction <span style="color:#ff79c6">*</span>ReadWriteTransaction) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//the current transaction is ready to commit, let&#39;s call it Tx.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> _, committedTransaction <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> oracle.committedTransactions {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">//ignore the committedTransaction if its commitTimestamp &lt;= Tx&#39;s beginTimestamp. 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> committedTransaction.commitTimestamp <span style="color:#ff79c6">&lt;=</span> transaction.beginTimestamp {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">//if the commitTimestamp of any transaction Ty &gt; Tx&#39;s beginTimestamp, and 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">//the transaction Ty contains any of the keys read by the Tx, then abort Tx.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">for</span> _, key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> transaction.reads {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> committedTransaction.transaction.batch.<span style="color:#50fa7b">Contains</span>(key) {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Oracle</code> can not store infinite number of ready-to-commit transactions in RAM, so the state needs to be cleared. It is safe to clean up all the
ready-to-commit transactions which have a <code>commitTimestamp</code> that is less than or equal to the maximum <code>beginTimestamp</code> of any transaction.
<a href="#implementing-transactiontimestampmark">TransactionTimestampMark</a>
 helps in identifying the <code>maxBeginTransactionTimestamp</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (oracle <span style="color:#ff79c6">*</span>Oracle) <span style="color:#50fa7b">cleanupCommittedTransactions</span>() {
</span></span><span style="display:flex;"><span>	updatedCommittedTransactions <span style="color:#ff79c6">:=</span> oracle.committedTransactions[:<span style="color:#bd93f9">0</span>]
</span></span><span style="display:flex;"><span>	maxBeginTransactionTimestamp <span style="color:#ff79c6">:=</span> oracle.beginTimestampMark.<span style="color:#50fa7b">DoneTill</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//clean up the committedTransactions:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//remove all the committedTransactions with commitTimestamp &lt;= maxBeginTransactionTimestamp.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> _, transaction <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> oracle.committedTransactions {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> transaction.commitTimestamp <span style="color:#ff79c6">&lt;=</span> maxBeginTransactionTimestamp {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		updatedCommittedTransactions = <span style="color:#8be9fd;font-style:italic">append</span>(updatedCommittedTransactions, transaction)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	oracle.committedTransactions = updatedCommittedTransactions
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Oracle only tracks ReadWriteTransactions. ReadonlyTransactions never abort and never participate in conflict detection.</p>
</blockquote>
<p>Let&rsquo;s now take a look the <code>Get</code> method of <code>ReadWriteTransaction</code>.</p>
<h4 id="get">Get</h4>
<p>The <code>Get</code> method tries to get the value of the key from <code>Batch</code>, and if the value is not found, it uses <code>MemTable</code> to get the value.
<em>Tracking the read keys is an important step involved in the <code>Get</code> method</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (transaction <span style="color:#ff79c6">*</span>ReadWriteTransaction) <span style="color:#50fa7b">Get</span>(key []<span style="color:#8be9fd">byte</span>) (mvcc.Value, <span style="color:#8be9fd">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> value, ok <span style="color:#ff79c6">:=</span> transaction.batch.<span style="color:#50fa7b">Get</span>(key); ok {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> mvcc.<span style="color:#50fa7b">NewValue</span>(value), <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    transaction.reads = <span style="color:#8be9fd;font-style:italic">append</span>(transaction.reads, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	versionedKey <span style="color:#ff79c6">:=</span> mvcc.<span style="color:#50fa7b">NewVersionedKey</span>(key, transaction.beginTimestamp)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> transaction.memtable.<span style="color:#50fa7b">Get</span>(versionedKey)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (batch <span style="color:#ff79c6">*</span>Batch) <span style="color:#50fa7b">Get</span>(key []<span style="color:#8be9fd">byte</span>) ([]<span style="color:#8be9fd">byte</span>, <span style="color:#8be9fd">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, pair <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> batch.pairs {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> bytes.<span style="color:#50fa7b">Compare</span>(pair.key, key) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">return</span> pair.value, <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s now understand how transactions are applied to the state machine.</p>
<h4 id="implementing-transactionexecutor">Implementing TransactionExecutor</h4>
<p><code>TransactionExecutor</code> is implemented as single goroutine that accepts <code>TimestampedBatch</code>es and applies them serially. It can be considered an
implementation of <a href="https://martinfowler.com/articles/patterns-of-distributed-systems/singular-update-queue.html" target="_blank" rel="noopener">singular update queue</a>
.</p>
<p>It contains a pointer to <code>MemTable</code> to which the changes the applied and a couple of channels.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> TransactionExecutor <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	batchChannel <span style="color:#8be9fd;font-style:italic">chan</span> TimestampedBatch
</span></span><span style="display:flex;"><span>	stopChannel  <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>	memtable     <span style="color:#ff79c6">*</span>mvcc.MemTable
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewTransactionExecutor</span>(memtable <span style="color:#ff79c6">*</span>mvcc.MemTable) <span style="color:#ff79c6">*</span>TransactionExecutor {
</span></span><span style="display:flex;"><span>	transactionExecutor <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>TransactionExecutor{
</span></span><span style="display:flex;"><span>		batchChannel: <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> TimestampedBatch),
</span></span><span style="display:flex;"><span>		stopChannel:  <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}),
</span></span><span style="display:flex;"><span>		memtable:     memtable,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">go</span> transactionExecutor.<span style="color:#50fa7b">spin</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> transactionExecutor
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Anytime a transaction is ready to commit, its <code>Batch</code> is converted to <code>TimestampedBatch</code> and submitted to <code>TransactionExecutor</code>, which reads
batches from the <code>batchChannel</code> and applies all the key/value pairs present in each batch to the <code>MemTable</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (executor <span style="color:#ff79c6">*</span>TransactionExecutor) <span style="color:#50fa7b">Submit</span>(batch TimestampedBatch) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} {
</span></span><span style="display:flex;"><span>	executor.batchChannel <span style="color:#ff79c6">&lt;-</span> batch
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> batch.doneChannel
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (executor <span style="color:#ff79c6">*</span>TransactionExecutor) <span style="color:#50fa7b">spin</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">case</span> timestampedBatch <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>executor.batchChannel:
</span></span><span style="display:flex;"><span>			executor.<span style="color:#50fa7b">apply</span>(timestampedBatch)
</span></span><span style="display:flex;"><span>			executor.<span style="color:#50fa7b">markApplied</span>(timestampedBatch)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>executor.stopChannel:
</span></span><span style="display:flex;"><span>			<span style="color:#8be9fd;font-style:italic">close</span>(executor.batchChannel)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Why are transactions applied using a single goroutine?</p>
<p>In the real world, applying a transaction would mean writing it to <a href="https://martinfowler.com/articles/patterns-of-distributed-systems/write-ahead-log.html" target="_blank" rel="noopener">WAL</a>
 and the state machine.
If the transactions are not applied by a single goroutine, the system would need locks to prevent concurrent modifications. These locks
would block other goroutines because tasks like writing to WAL
are time-consuming.</p>
<p>Using an approach like singular update queue also allows transactions to be applied in order.</p>
</blockquote>
<h4 id="implementing-transactiontimestampmark">Implementing TransactionTimestampMark</h4>
<p>In order to manage transactions effectively, we need a mechanism to  track two indices:</p>
<ul>
<li><strong>Latest commit index</strong>: This index indicates the point up to which transactions have been successfully applied.
It is useful for functions like <a href="https://github.com/SarthakMakhija/serialized-snapshot-isolation/blob/main/txn/Oracle.go#L70" target="_blank" rel="noopener">Oracle.beginTimestamp</a>
.</li>
<li><strong>Latest begin index</strong>: This index signifies the <code>beginTimestamp</code> of the most recent transaction.
It is helpful for functions like <a href="https://github.com/SarthakMakhija/serialized-snapshot-isolation/blob/main/txn/Oracle.go#L145" target="_blank" rel="noopener">Oracle.cleanupCommittedTransactions</a>
.</li>
</ul>
<p>Such an mechanism is provided by <a href="https://github.com/SarthakMakhija/serialized-snapshot-isolation/blob/main/txn/TransactionTimestampMark.go" target="_blank" rel="noopener">TransactionTimestampMark</a>
.
Each instance of <code>TransactionTimestampMark</code> runs as a goroutine. <code>Oracle</code> maintains two marks:</p>
<ol>
<li><code>beginTimestampMark</code> is used to indicate till what timestamp transactions have begun.</li>
<li><code>commitTimestampMark</code> is used to indicate till what timestamp transactions have been successfully applied.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Oracle <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	beginTimestampMark    <span style="color:#ff79c6">*</span>TransactionTimestampMark
</span></span><span style="display:flex;"><span>	commitTimestampMark   <span style="color:#ff79c6">*</span>TransactionTimestampMark
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//other fields removed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p>Let&rsquo;s take an example of tracking the <code>beginTimestamp</code>.</p>
<div class="align-center-exclude-width-change">
    <img src="/transaction_timestamp_mark.webp" alt="Transaction marks"/>
</div>
<ol>
<li>Consider <code>ReadonlyTransaction</code>(s) <strong>Tx</strong>, <strong>Ty</strong> and <strong>Tz</strong>. <strong>Tx</strong> and <strong>Ty</strong> begin at timestamp 20 and <strong>Tz</strong> begins at timestamp 21.
Anytime a transaction begins, <code>beginTimestampMark</code> is notified. The <code>TransactionTimestampMark</code> keeps a track of all the pending transaction requests
by timestamp. After the transactions have begun, the state of <code>TransactionTimestampMark</code> looks like the following:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">pendingTransactionRequestsByTimestamp</span> <span style="color:#ff79c6">=</span>&gt; <span style="color:#ff79c6">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#bd93f9">20</span> : 2,
</span></span><span style="display:flex;"><span>    21: <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">]</span>
</span></span></code></pre></div><ol start="2">
<li>The transactions <strong>Tx</strong> and <strong>Tx</strong> finish. Despite being readonly transactions, every time they finish, <code>beginTimestampMark</code> is notified.
The state of <code>TransactionTimestampMark</code> looks like the following:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">pendingTransactionRequestsByTimestamp</span> <span style="color:#ff79c6">=</span>&gt; <span style="color:#ff79c6">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#bd93f9">20</span> : 1,
</span></span><span style="display:flex;"><span>    21: <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">]</span>
</span></span></code></pre></div><p>Even though there is no transaction at the <code>beginIndex</code> of 21, we can not return 21 as the <strong>Latest begin index</strong> because there is a transaction
which is yet to finish at the index 20. Effectively, <a href="https://github.com/SarthakMakhija/serialized-snapshot-isolation/blob/main/txn/TransactionTimestampMark.go" target="_blank" rel="noopener">TransactionTimestampMark</a>

maintains a <a href="https://en.wikipedia.org/wiki/Binary_heap" target="_blank" rel="noopener">binary heap</a>
 to keep track of all indices.</p>
<ol start="3">
<li>The readonly transaction <strong>Ty</strong> finishes. The state of <code>TransactionTimestampMark</code> looks like the following:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">pendingTransactionRequestsByTimestamp</span> <span style="color:#ff79c6">=</span>&gt; <span style="color:#ff79c6">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#bd93f9">20</span> : 0,
</span></span><span style="display:flex;"><span>    21: <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">]</span>
</span></span></code></pre></div><p>At this stage, <code>TransactionTimestampMark</code> can return 21 as the <strong>Latest begin index</strong> and <code>Oracle</code> can then clean up the committed transactions
based on this information.</p>
<p>In conclusion, Serializable Snapshot isolation combines Snapshot isolation and serial execution of transactions. We have all the
pieces which can be combined to get a fully functional implementation of Serializable Snapshot isolation. The code is available
<a href="https://github.com/SarthakMakhija/serialized-snapshot-isolation" target="_blank" rel="noopener">here</a>
.</p>
<h3 id="mentions">Mentions</h3>
<ul>
<li><a href="https://bard.google.com/chat" target="_blank" rel="noopener">Google Bard</a>
 helped with the article.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dgraph-io/badger" target="_blank" rel="noopener">BadgerDb</a>
</li>
<li><a href="https://kt.academy/article/pmem-design-choices-and-use-cases#selective-persistence" target="_blank" rel="noopener">Skip List</a>
</li>
<li><a href="https://dl.acm.org/doi/10.1145/2168836.2168853" target="_blank" rel="noopener">A critique of snapshot isolation</a>
</li>
</ul>

  </article>
<div class="tag-list-container">
    <div class="tag-list">
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Golang</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Transaction</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Isolation</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Serializable Snapshot Isolation</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>BadgerDb</p>
        </a>
        
    </div>
</div>



<div class="px-2 mb-2">
  
  <script src="https://giscus.app/client.js"
    data-repo="SarthakMakhija/tech-lessons-comments"
    data-repo-id="R_kgDOJHu3mA"
    data-category="Announcements"
    data-category-id="DIC_kwDOJHu3mM4CUxhS"
    data-mapping="og:title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
  </script>
  
</div>



    </main><footer class="container p-6 mx-auto flex justify-between items-center">
  <span></span>

  <span class="text-base font-thin">
    
    tech-lessons.in  2020 / Powered by  <a class="font-bold" target="_blank" href="https://gohugo.io/">Hugo</a>
    
  </span>

  <span onclick="window.scrollTo({top: 0, behavior: 'smooth'})" class="p-1 cursor-pointer">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5"
      stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M18 15l-6 -6l-6 6h12" />
    </svg>
  </span>
</footer>

<div class="search-ui absolute top-0 left-0 w-full h-full bg-white dark:bg-gray-800 hidden">
  <div class="container max-w-3xl mx-auto p-12">
    <div class="relative">
      <div class="my-4 text-center text-2xl font-bold">Search</div>

      <span class="p-2 absolute right-0 top-0 cursor-pointer close-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </svg>
      </span>
    </div>

    <input type="search" class="py-2 px-3 w-full dark:text-black border dark:border-transparent"
      placeholder="Enter search query" />

    <div class="search-results text-lg font-medium my-4 hidden">Results</div>
    <ul class="search-list my-2">

    </ul>

    <div class="no-results text-center my-8 hidden">
      <div class="text-xl font-semibold mb-2">No results found</div>
      <p class="font-light text-sm">Try adjusting your search query</p>
    </div>
  </div>
</div>





<script src="//localhost:1313/js/scripts.min.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9KKTKFQ2CM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9KKTKFQ2CM');
        }
      </script>





<script>
  const mobileMenuButton = document.querySelector('.mobile-menu-button')
  const mobileMenu = document.querySelector('.mobile-menu')
  function toggleMenu() {
    mobileMenu.classList.toggle('hidden');
    mobileMenu.classList.toggle('flex');
  }
  if(mobileMenu && mobileMenuButton){
    mobileMenuButton.addEventListener('click', toggleMenu)
  }
</script>
</body>
</html>
