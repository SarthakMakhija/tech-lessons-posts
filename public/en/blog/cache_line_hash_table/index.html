<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" href="/favicon.png">

  <title>
  Cache-Line Hash Table - tech-lessons.in
  </title>
  <meta name="description" content=" In the world of multi-core processors, managing concurrent access to data structures is crucial for efficient performance. But frequent updates can trigger a hidden bottleneck: cache coherence traffic. This traffic arises when one core modifies the data another core has cached, forcing updates and invalidation across the system. This article dives into a clever solution: the Cache-Line Hash Table (CLHT).  CLHTs are specifically designed to minimize this cache coherence traffic, boosting the speed of concurrent data access. " />
  <meta name="author" content="Sarthak Makhija" />
  
     <meta property="og:image" content="/clht_title.webp" />
  <meta name="generator" content="Hugo 0.140.1"><link rel="stylesheet" href="/css/styles.css" />

  
  

  <meta property="og:url" content="//localhost:1313/en/blog/cache_line_hash_table/">
  <meta property="og:site_name" content="tech-lessons.in">
  <meta property="og:title" content="Cache-Line Hash Table">
  <meta property="og:description" content="In the world of multi-core processors, managing concurrent access to data structures is crucial for efficient performance. But frequent updates can trigger a hidden bottleneck: cache coherence traffic. This traffic arises when one core modifies the data another core has cached, forcing updates and invalidation across the system. This article dives into a clever solution: the Cache-Line Hash Table (CLHT).  CLHTs are specifically designed to minimize this cache coherence traffic, boosting the speed of concurrent data access.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2024-04-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-04-19T00:00:00+00:00">
    <meta property="article:tag" content="CPU Cache-Line">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="CLHT">
    <meta property="article:tag" content="Cache-Line Hash Table">
    <meta property="article:tag" content="Golang">
    <meta property="article:tag" content="Xsync">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Cache-Line Hash Table">
  <meta name="twitter:description" content="In the world of multi-core processors, managing concurrent access to data structures is crucial for efficient performance. But frequent updates can trigger a hidden bottleneck: cache coherence traffic. This traffic arises when one core modifies the data another core has cached, forcing updates and invalidation across the system. This article dives into a clever solution: the Cache-Line Hash Table (CLHT).  CLHTs are specifically designed to minimize this cache coherence traffic, boosting the speed of concurrent data access.">

  
  <meta itemprop="name" content="Cache-Line Hash Table">
  <meta itemprop="description" content="In the world of multi-core processors, managing concurrent access to data structures is crucial for efficient performance. But frequent updates can trigger a hidden bottleneck: cache coherence traffic. This traffic arises when one core modifies the data another core has cached, forcing updates and invalidation across the system. This article dives into a clever solution: the Cache-Line Hash Table (CLHT).  CLHTs are specifically designed to minimize this cache coherence traffic, boosting the speed of concurrent data access.">
  <meta itemprop="datePublished" content="2024-04-19T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-04-19T00:00:00+00:00">
  <meta itemprop="wordCount" content="3450">
  <meta itemprop="keywords" content="CPU Cache-Line,Hash Table,CLHT,Cache-Line Hash Table,Golang,Xsync">

  
</head>
<body class="dark:bg-gray-800 dark:text-white relative flex flex-col min-h-screen"><header class="container flex justify-between md:justify-between gap-4 flex-wrap p-6 mx-auto relative">
  <a href="//localhost:1313/en/" class="capitalize font-extrabold text-2xl">
    
    <img src="/logo.png" alt="tech-lessons.in" class="h-8 max-w-full" />
    
  </a>
  <button class="mobile-menu-button md:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <line x1="4" y1="8" x2="20" y2="8" />
      <line x1="4" y1="16" x2="20" y2="16" />
    </svg>
  </button>
  <ul class="mobile-menu absolute z-10 px-6 pb-6 md:p-0 top-full left-0 w-full md:w-auto md:relative hidden md:flex flex-col md:flex-row items-end md:items-center gap-4 lg:gap-6 bg-white dark:bg-gray-800">

    
    <li><a href="/en/">Home</a></li>
    
    <li><a href="/en/blog">Blogs</a></li>
    
    <li><a href="/en/page/about/">About Me</a></li>
    
    <li><a href="/en/page/projects/">My projects</a></li>
    

    

    
    <li class="grid place-items-center">
      <span class="open-search inline-block cursor-pointer">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <circle cx="10" cy="10" r="7" />
          <line x1="21" y1="21" x2="15" y2="15" />
        </svg>
      </span>
    </li>
    

    
  </ul>
</header>
<main class="flex-1">
  
  

  
  <div class="relative max-w-5xl mx-auto px-4">
    <img src="/clht_title.webp" class="rounded-lg shadow-sm w-full object-contain" />
    
    <figcaption class="font-extralight text-xs"><i>Bakckground by Eva Bronzini on Pexels</i></figcaption>
    
    
    <div class="absolute top-4 right-8 rounded shadow bg-white text-gray-900 dark:bg-gray-900 dark:text-white px-2 py-0.5">
      
  
    April 19, 2024
  


    </div>
    
  </div>
  

  <article class="prose lg:prose-lg mx-auto my-8 dark:prose-dark px-4 max-w-5xl">

    <h1 class="text-2xl font-bold mb-2">Cache-Line Hash Table</h1>
    
    <h5 class="text-sm flex items-center flex-wrap">
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <rect x="4" y="5" width="16" height="16" rx="2" />
        <line x1="16" y1="3" x2="16" y2="7" />
        <line x1="8" y1="3" x2="8" y2="7" />
        <line x1="4" y1="11" x2="20" y2="11" />
        <rect x="8" y="15" width="2" height="2" />
      </svg>
      Posted on 
  
    April 19, 2024
  


      
        &nbsp;&bull;&nbsp;
      
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <circle cx="12" cy="12" r="9" />
        <polyline points="12 7 12 12 15 15" />
      </svg>
      17&nbsp;minutes
      &nbsp;&bull;
      <svg xmlns="http://www.w3.org/2000/svg" class="mx-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <path d="M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <path d="M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <line x1="3" y1="6" x2="3" y2="19" />
        <line x1="12" y1="6" x2="12" y2="19" />
        <line x1="21" y1="6" x2="21" y2="19" />
      </svg>
      3450&nbsp;words
      
    </h5>
    

    <details id="TableOfContents" class="px-4 mt-4 bg-gray-100 dark:bg-gray-700 rounded toc">
    <summary class="flex items-center font-bold py-2 px-4 cursor-pointer justify-between select-none text-black dark:text-white">
      <span>Table of contents</span>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <polyline points="6 9 12 15 18 9"></polyline>
     </svg>
    </summary>

    <ul class="mt-2 pb-4">
        

        
        <li>
        <a href="#introduction">Introduction</a>
        

        
        </li><li>
        <a href="#understanding-cpu-cache-line-and-cache-coherency">Understanding CPU Cache line and Cache Coherency</a>
        

        
        </li><li>
        <a href="#understanding-clht-cache-line-hash-table">Understanding CLHT (Cache-Line Hash table)</a>
        

        
        </li><li>
        <a href="#understanding-the-load-operation">Understanding the Load Operation</a>
        

        
        </li><li>
        <a href="#understanding-the-store-operation">Understanding the Store Operation</a>
        

        
        <ul>
            <li>
        <a href="#identifying-the-bucket">Identifying the bucket</a>
        

        
        </li><li>
        <a href="#acquire-a-lock-on-the-identified-bucket">Acquire a lock on the identified bucket</a>
        

        
        </li><li>
        <a href="#identify-an-empty-entry-slot">Identify an empty entry slot</a>
        

        
        </li><li>
        <a href="#store-the-keyvalue-pair-in-an-empty-entry-slot">Store the key/value pair in an empty entry slot</a>
        

        
        </li><li>
        <a href="#store-in-a-new-bucket-if-all-the-linearly-linked-buckets-at-the-identified-bucket-index-are-full">Store in a new bucket, if all the linearly linked buckets at the identified bucket index are full</a>
        

        
        </li></ul>
      </li><li>
        <a href="#understanding-the-resize-operation">Understanding the Resize Operation</a>
        

        
        <ul>
            <li>
        <a href="#ensure-one-resize-at-a-time">Ensure one resize at a time</a>
        

        
        </li><li>
        <a href="#access-the-current-table-atomically">Access the current table atomically</a>
        

        
        </li><li>
        <a href="#increase-the-table-size-locally">Increase the table size locally</a>
        

        
        </li><li>
        <a href="#remap-the-existing-keys">Remap the existing keys</a>
        

        
        </li><li>
        <a href="#finish-resize">Finish resize</a>
        

        
        </li></ul>
      </li><li>
        <a href="#conclusion">Conclusion</a>
        

        
        </li><li>
        <a href="#mentions">Mentions</a>
        

        
        </li><li>
        <a href="#references">References</a>
        </li></ul>
  </details>

    <h3 id="introduction">Introduction</h3>
<p>In the world of multi-core processors, managing concurrent access to data structures is crucial for efficient performance. But frequent updates can trigger a hidden bottleneck: cache coherence traffic. This traffic arises when one core modifies the data another core has cached, forcing updates and invalidation across the system.</p>
<p>This article dives into a clever solution: the Cache-Line Hash Table (CLHT).  CLHTs are specifically designed to minimize this cache coherence traffic, boosting the speed of concurrent data access. We&rsquo;ll explore the core ideas behind CLHTs, including:</p>
<ul>
<li><strong>One Bucket Per CPU Cache-Line</strong>: By cleverly aligning buckets with CPU cache line sizes, CLHTs minimize the number of lines written during updates.</li>
<li><strong>In-Place Updates</strong>: Instead of shuffling data around, CLHTs update key-value pairs directly within the bucket, reducing memory movement.</li>
<li><strong>Lock-Free Reads</strong>: Reads are designed to be lock-free, meaning they can proceed without acquiring locks, further enhancing performance.</li>
</ul>
<h3 id="understanding-cpu-cache-line-and-cache-coherency">Understanding CPU Cache line and Cache Coherency</h3>
<p>To execute an instruction, CPUs need to fetch the instruction and its data (John von Neumannâ€™s design) (from RAM/caches). Accessing RAM (/DRAM) for fetching data and instruction is expensive, usually in the orders of 50-100ns. To minimize the latency cost, CPUs have caches: L1, L2, L3 and in some cases L4. While L1 and L2 caches are private to each core, L3 can be shared between cores. The size of these caches increase from L1 to L4, and so does the latency cost.</p>
<p>Let&rsquo;s focus on data access.</p>
<p>Anytime a CPU executes an operation, it checks for the required data in the cache hierarchy, in the following order L1, L2, L3 and (/L4). If the data is not available in any of these caches, it is fetched from RAM and stored in these caches.</p>
<p>Let&rsquo;s consider that a program needs to read the value at index <code>i</code> of an <code>uint64</code> array. When a CPU executes this instruction, it won&rsquo;t fetch just the <code>8 bytes</code> of value. Instead, it will fetch a contiguous chunk of memory, on x86 systems this chunk is 64 bytes in size. This chunk is called <strong>CPU cache line</strong>. This means, all the CPU caches organize the data in form of cache lines. This approach improves efficiency by fetching multiple potentially related pieces of data in one go.</p>
<p>On multi-core processors it is possible for multiple cores to cache the same chunk of memory in their own L1 or L2 cache. This means, the same cache line can be present in different cores.</p>
<p>Continuing with our previous example of the arrray, imagine a thread <em>A</em> running on CPU 1 and other thread <em>B</em> running on CPU 2 have cached the same cache line corresponding to the array indices 0-7. Consider that thread <em>A</em> modifies the value at index 5. This means the cached copy of this cache line is stale on CPU 2.</p>
<p><strong>Cache coherency</strong> is the problem of ensuring that local caches in a multi-core processor system stay in sync. The problem is solved by a hardware device called &ldquo;cache controller&rdquo; which will invalidate the local copy of the cache on CPU 2 and the invalidated cache line will be refetched from RAM.</p>
<p>One of the goals behind CLHTs is to minimize this cache coherence traffic.</p>
<h3 id="understanding-clht-cache-line-hash-table">Understanding CLHT (Cache-Line Hash table)</h3>
<p>CLHT stands for cache-line hash table as it tries to put one bucket per CPU cache line. The core idea behind the design of CLHT is to minimize the amount cache coherence traffic. In concurrent data structures, <strong>cache coherence traffic</strong> is generated when a thread running on a core updates a cache line while the other remote cores hold the same cache line. In this scenario, cache coherence protocol would kick in, thus requiring the other cores to invalidate the cache line and fetch it from RAM.</p>
<p>CLHT has the following ideas:</p>
<ul>
<li>Minimize the cache coherence traffic by reducing the number of cache lines that are written in a store operation</li>
<li>Perform in-place update of key/value pairs</li>
<li>Take no locks during read (/get) operations</li>
</ul>
<p>I will be taking the example of the <a href="https://github.com/puzpuzpuz/xsync/blob/main/mapof.go" target="_blank" rel="noopener">MapOf</a>
 implementation from <a href="https://github.com/puzpuzpuz/xsync/" target="_blank" rel="noopener">xsync</a>
 which is a CLHT-inspired concurrent hash map.</p>
<p>The core abstraction <code>MapOf</code> contains an <a href="https://pkg.go.dev/unsafe#Pointer" target="_blank" rel="noopener">unsafe pointer</a>
 to the <code>mapOfTable</code> struct.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> MapOf[K comparable, V any] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//other fields omitted.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	table        unsafe.Pointer <span style="color:#6272a4">// *mapOfTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p>The abstraction <code>mapOfTable</code> contains a slice of buckets.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">const</span> entriesPerMapBucket = <span style="color:#bd93f9">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> mapOfTable[K comparable, V any] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//other fields omitted.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	buckets []bucketOfPadded
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> bucketOfPadded <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    pad [cacheLineSize <span style="color:#ff79c6">-</span> unsafe.<span style="color:#50fa7b">Sizeof</span>(bucketOf{})]<span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>    bucketOf
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> bucketOf <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    hashes  [entriesPerMapBucket]<span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    entries [entriesPerMapBucket]unsafe.Pointer <span style="color:#6272a4">// *entryOf
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    next    unsafe.Pointer                      <span style="color:#6272a4">// *bucketOfPadded
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    mu      sync.Mutex
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> entryOf[K comparable, V any] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    key   K
</span></span><span style="display:flex;"><span>    value V
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The buckets are linearly linked using the <code>next</code> field at each index. CLHT puts one bucket per CPU cache line, this simply means that the size of each bucket should be equal to the <a href="https://docs.rs/crossbeam-utils/latest/crossbeam_utils/struct.CachePadded.html" target="_blank" rel="noopener">CPU cache line size</a>
.</p>
<p>With <code>entriesPerMapBucket</code> as 3, the size of a single instance of <code>bucketOf</code> is 64 bytes, which is the size of CPU cache line on x86 systems.
Each instance of <code>bucketOf</code> contains three hashes and three entries.</p>
<p>Each entry is an unsafe pointer to the <code>entryOf</code> struct which contains a key/value pair.</p>
<blockquote>
<p>The abstraction <code>MapOf</code> uses unsafe pointers which are later used in atomic pointer operations, like <code>atomic.StorePointer(&amp;b.entries[i], unsafe.Pointer(newEntry))</code>.</p>
</blockquote>
<blockquote>
<p>An unsafe pointer represents a pointer an arbitrary type.
Let&rsquo;s take a quick example of converting a byte slice to string using unsafe.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">toString</span>(buffer []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">string</span> {
</span></span><span style="display:flex;"><span>   unsafePointer <span style="color:#ff79c6">:=</span> unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>buffer)
</span></span><span style="display:flex;"><span>   stringPointer <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>)(unsafePointer)
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">*</span>stringPointer
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This snippet creates an unsafe pointer using the address of the byte slice, casts it to a string pointer and then
dereferences it to get string. This works because both the byte slice and the string share an equivalent memory
layout and the resulting string is not larger than the input byte slice.</p>
</blockquote>
<p>The design of xsync <code>MapOf</code> is presented in the below image.</p>
<div class="align-center-exclude-width-change">
    <img src="/xsync.webp" alt="Design of xsync MapOf"/>
</div>
<h3 id="understanding-the-load-operation">Understanding the Load Operation</h3>
<p>The <code>Load</code> operation returns the value if the target key is present, else returns a zero value of type V.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (m <span style="color:#ff79c6">*</span>MapOf[K, V]) <span style="color:#50fa7b">Load</span>(key K) (value V, ok <span style="color:#8be9fd">bool</span>) {
</span></span><span style="display:flex;"><span>	table <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>mapOfTable[K, V])(atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>m.table))
</span></span><span style="display:flex;"><span>	hash <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">shiftHash</span>(m.<span style="color:#50fa7b">hasher</span>(key, table.seed))
</span></span><span style="display:flex;"><span>	bucketIndex <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint64</span>(<span style="color:#8be9fd;font-style:italic">len</span>(table.buckets)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&amp;</span> hash
</span></span><span style="display:flex;"><span>	rootBucket <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>table.buckets[bucketIndex]
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; entriesPerMapBucket; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>			h <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadUint64</span>(<span style="color:#ff79c6">&amp;</span>rootBucket.hashes[i])
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> h <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">uint64</span>(<span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">||</span> h <span style="color:#ff79c6">!=</span> hash {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			entryPointer <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>rootBucket.entries[i])
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> entryPointer <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			entry <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>entryOf[K, V])(entryPointer)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> entry.key <span style="color:#ff79c6">==</span> key {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> entry.value, <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		bucketPointer <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>rootBucket.next)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> bucketPointer <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		rootBucket = (<span style="color:#ff79c6">*</span>bucketOfPadded)(bucketPointer)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The idea behind the <code>Load</code> operation can be summarized as:</p>
<ul>
<li>Identify the <code>bucketIndex</code> where the target key may be present. The operation <code>uint64(len(table.buckets)-1) &amp; hash</code> is same as <code>hash % number of buckets</code>.</li>
<li>Iterate through all entries present in the bucket. There are only three entries in each bucket.</li>
<li>Skip if the hash of the target key does not match the hash at the index <code>i</code> in the bucket.</li>
<li>Atomically load the entry at the index <code>i</code> if the hash at that index matches the hash of the target key.</li>
<li>Compare the target key and the key present in the loaded entry.</li>
<li>Return if the keys match, else continue.</li>
<li>Move onto the next bucket, if present, by atomically loading the next bucket pointer.</li>
</ul>
<p>Here&rsquo;s a breakdown of the takeaways:</p>
<ol>
<li><strong>Faster comparison using hashes</strong></li>
</ol>
<p>Hash comparison (comparing <code>uint64</code> bits -&gt; 8 bytes) is faster than comparing the actual keys, if the keys are bigger than 8 bytes.
This is an optimization where the keys are only compared after the hash of the target key matches with the hash at an index <code>i</code>. There could be false positives (two keys may have the same hash), hence key comparison is eventually needed.</p>
<ol start="2">
<li><strong>No locks</strong></li>
</ol>
<p>The method <code>Load</code> does not use locks, it loads the three fields (entries, next pointer and hashes) atomically. This means, the <code>Load</code> method will always see their values either before or after the write operation.</p>
<ol start="3">
<li><strong>Cache aligned buckets</strong></li>
</ol>
<p>CLHT puts one bucket per CPU cache line. The <code>Load</code> operation loads the entire bucket (cache line) from RAM to the CPU cache(s). Since, the
entire bucket is loaded in CPU cache(s), any further comparison on entries in the bucket will not need to access RAM.</p>
<h3 id="understanding-the-store-operation">Understanding the Store Operation</h3>
<p>The method <code>Store</code> stores the key/value pair in the map.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (m <span style="color:#ff79c6">*</span>MapOf[K, V]) <span style="color:#50fa7b">Store</span>(key K, value V) {
</span></span><span style="display:flex;"><span>	m.<span style="color:#50fa7b">doCompute</span>(
</span></span><span style="display:flex;"><span>		key,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">func</span>(V, <span style="color:#8be9fd">bool</span>) (V, <span style="color:#8be9fd">bool</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> value, <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">false</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">false</span>,
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This method calls <code>doCompute</code>, so we will take a look at that method. However, <code>doCompute</code> does multiple things. So, we will take a look at it in parts.</p>
<h4 id="identifying-the-bucket">Identifying the bucket</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>table <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>mapOfTable[K, V])(atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>m.table))
</span></span><span style="display:flex;"><span>tableLen <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">len</span>(table.buckets)
</span></span><span style="display:flex;"><span>hash <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">shiftHash</span>(m.<span style="color:#50fa7b">hasher</span>(key, table.seed))
</span></span><span style="display:flex;"><span>bucketIndex <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint64</span>(<span style="color:#8be9fd;font-style:italic">len</span>(table.buckets)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&amp;</span> hash
</span></span></code></pre></div><p>The idea can be summarized as:</p>
<ul>
<li>Load the <code>table</code> atomically using <code>atomic.LoadPointer(&amp;m.table)</code>. The field <code>table</code> is an unsafe pointer that refers to an instance of <code>mapOfTable</code>.</li>
<li>Identify the <code>bucketIndex</code> where the target key has to be stored. The operation <code>uint64(len(table.buckets)-1) &amp; hash</code> is same as <code>hash % number of buckets</code>.</li>
</ul>
<blockquote>
<p>The field table is refers to an instance of <code>mapOfTable</code>. The abstraction <code>mapOfTable</code> contains a collection of buckets.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> mapOfTable[K comparable, V any] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">//other fields omitted.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  buckets []bucketOfPadded
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To ensure that there is always the latest information of the <code>table</code> field, it is loaded atomically.
This atomic access becomes crucial because a previous resize operation might have already changed the internal
structure of the map (adding or removing buckets).
By reading atomically, we avoid any inconsistencies that could lead to errors.</p>
</blockquote>
<h4 id="acquire-a-lock-on-the-identified-bucket">Acquire a lock on the identified bucket</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>rootBucket <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>table.buckets[bucketIndex]
</span></span><span style="display:flex;"><span>rootBucket.mu.<span style="color:#50fa7b">Lock</span>()
</span></span></code></pre></div><p>To prevent multiple goroutines from writing to the same bucket simultaneously, each bucket has a lock. This lock, of the type <code>sync.Mutex</code> in Go, is acquired
within the <code>doCompute</code> method. This ensures that only one goroutine can modify a particular bucket at any given time.</p>
<h4 id="identify-an-empty-entry-slot">Identify an empty entry slot</h4>
<p>This involves finding an empty entry slot in an existing bucket.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; entriesPerMapBucket; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>    hashValue <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadUint64</span>(<span style="color:#ff79c6">&amp;</span>currentBucket.hashes[i])
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> hashValue <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">uint64</span>(<span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> emptyb <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            emptyb = currentBucket
</span></span><span style="display:flex;"><span>            emptyidx = i
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> hashValue <span style="color:#ff79c6">!=</span> hash {
</span></span><span style="display:flex;"><span>        hintNonEmpty<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    entry <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>entryOf[K, V])(currentBucket.entries[i])
</span></span><span style="display:flex;"><span>    hintNonEmpty<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The idea can be summarized as:</p>
<ul>
<li>Iterate through all entries present in the bucket. There are only three entries in each bucket.</li>
<li>Check if the hashValue at index <code>i</code> is zero. Zero hash value signifies an empty entry slot.</li>
<li>If the hashValue at index <code>i</code> is zero, capture the current bucket and the index. This is where the new entry will be stored, if there is no next bucket.</li>
</ul>
<h4 id="store-the-keyvalue-pair-in-an-empty-entry-slot">Store the key/value pair in an empty entry slot</h4>
<p>This involves storing the key/value pair in the existing bucket at an empty entry slot.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff79c6">if</span> currentBucket.next <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> emptyb <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// Insertion into an existing bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd;font-style:italic">var</span> zeroedV V
</span></span><span style="display:flex;"><span>        newValue, del <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">valueFn</span>(zeroedV, <span style="color:#ff79c6">false</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        newe <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">new</span>(entryOf[K, V])
</span></span><span style="display:flex;"><span>        newe.key = key
</span></span><span style="display:flex;"><span>        newe.value = newValue
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// First we update the hash, then the entry.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        atomic.<span style="color:#50fa7b">StoreUint64</span>(<span style="color:#ff79c6">&amp;</span>emptyb.hashes[emptyidx], hash)
</span></span><span style="display:flex;"><span>        atomic.<span style="color:#50fa7b">StorePointer</span>(<span style="color:#ff79c6">&amp;</span>emptyb.entries[emptyidx], unsafe.<span style="color:#50fa7b">Pointer</span>(newe))
</span></span><span style="display:flex;"><span>        rootBucket.mu.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>        table.<span style="color:#50fa7b">addSize</span>(bucketIndex, <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> newValue, computeOnly
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}	
</span></span></code></pre></div><p>The idea can be summarized as:</p>
<ul>
<li>Check if there is a next bucket. If there is none and an empty entry slot has been identified, write the new entry at the identified index in the existing bucket.</li>
<li>Create a new instance of <code>entryOf</code> and set the key and value.</li>
<li>Atomically store the hash of the key in the identified entry index using <code>atomic.StoreUint64(&amp;emptyb.hashes[emptyidx], hash)</code>.</li>
<li>Atomically store the entry pointer in the identified entry index using <code>atomic.StorePointer(&amp;emptyb.entries[emptyidx], unsafe.Pointer(newe))</code>.</li>
<li>Release the lock</li>
</ul>
<h4 id="store-in-a-new-bucket-if-all-the-linearly-linked-buckets-at-the-identified-bucket-index-are-full">Store in a new bucket, if all the linearly linked buckets at the identified bucket index are full</h4>
<p>Store the key/value pair in a new bucket and link the new bucket atomically.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff79c6">if</span> currentBucket.next <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Insertion into a new bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">var</span> zeroedV V
</span></span><span style="display:flex;"><span>    newValue, del <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">valueFn</span>(zeroedV, <span style="color:#ff79c6">false</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Create and append the bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    newb <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">new</span>(bucketOfPadded)
</span></span><span style="display:flex;"><span>    newb.hashes[<span style="color:#bd93f9">0</span>] = hash
</span></span><span style="display:flex;"><span>    newe <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">new</span>(entryOf[K, V])
</span></span><span style="display:flex;"><span>    newe.key = key
</span></span><span style="display:flex;"><span>    newe.value = newValue
</span></span><span style="display:flex;"><span>    newb.entries[<span style="color:#bd93f9">0</span>] = unsafe.<span style="color:#50fa7b">Pointer</span>(newe)
</span></span><span style="display:flex;"><span>    atomic.<span style="color:#50fa7b">StorePointer</span>(<span style="color:#ff79c6">&amp;</span>currentBucket.next, unsafe.<span style="color:#50fa7b">Pointer</span>(newb))
</span></span><span style="display:flex;"><span>    rootBucket.mu.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>    table.<span style="color:#50fa7b">addSize</span>(bucketIndex, <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> newValue, computeOnly
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The idea can be summarized as:</p>
<ul>
<li>Check if there is a next bucket. If there is none and no empty slot has been identified, create a new bucket.</li>
<li>Create a new instance of <code>entryOf</code> and set the key and value.</li>
<li>Store the new entry in the 0th index of the newly created bucket.</li>
<li>Atomically link the new bucket using <code>atomic.StorePointer(&amp;currentBucket.next, unsafe.Pointer(newb))</code></li>
<li>Release the lock</li>
</ul>
<p>The <code>Store</code> operation also checks if a <code>resize</code> operation is in progress.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff79c6">if</span> m.<span style="color:#50fa7b">resizeInProgress</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Resize is in progress. Wait, then go for another attempt.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    rootBucket.mu.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>    m.<span style="color:#50fa7b">waitForResize</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> compute_attempt
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> m.<span style="color:#50fa7b">newerTableExists</span>(table) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Someone resized the table. Go for another attempt.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    rootBucket.mu.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> compute_attempt
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (m <span style="color:#ff79c6">*</span>MapOf[K, V]) <span style="color:#50fa7b">resizeInProgress</span>() <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> atomic.<span style="color:#50fa7b">LoadInt64</span>(<span style="color:#ff79c6">&amp;</span>m.resizing) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (m <span style="color:#ff79c6">*</span>MapOf[K, V]) <span style="color:#50fa7b">newerTableExists</span>(table <span style="color:#ff79c6">*</span>mapOfTable[K, V]) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>	curTablePtr <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>m.table)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(curTablePtr) <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(unsafe.<span style="color:#50fa7b">Pointer</span>(table))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code ensures data consistency during writes even when the map is being resized. Here&rsquo;s how it works:</p>
<ul>
<li><strong>Resize in progress</strong></li>
</ul>
<p>If the <code>doCompute</code> operation detects a resize happening, it waits for the resize to finish. Then, it starts the entire operation from scratch to ensure it&rsquo;s working with the latest structure of the map.</p>
<ul>
<li><strong>Resize after invocation</strong></li>
</ul>
<p>If a resize happens after the <code>doCompute</code> operation has already begun (but wasn&rsquo;t ongoing at the start), the code recognizes this potential inconsistency. It releases the lock it might be holding and starts the entire operation again.
This guarantees the operation uses the most recent map structure.</p>
<p>Here&rsquo;s a breakdown of the takeaways from the <code>Store</code> operation:</p>
<ol>
<li><strong>Concurrent Safety with Bucket Locks</strong>:</li>
</ol>
<p>Each bucket has its own lock, to control writes. This lock (<code>sync.Mutex</code> in Go) is acquired in the <code>doCompute</code> method.
This ensures only one goroutine can modify a particular bucket at a time, preventing conflicts when multiple goroutines try to write to the same bucket at once.</p>
<ol start="2">
<li><strong>Balancing Buckets and Contention</strong>:</li>
</ol>
<p>If you have a large number of goroutines (like 9000) writing to the map, increasing the number of buckets can improve performance.
Think of buckets as separate lines at a store checkout. More buckets mean fewer goroutines waiting in line (contention) for the same bucket.
The ideal number of buckets should be determined through performance tests (benchmarks) to find the right balance.</p>
<ol start="3">
<li><strong>Atomic Operations for Consistency</strong>:</li>
</ol>
<p>Inside a bucket, the <code>Store</code> method updates three parts (next pointer, entry, and hash). These fields are written atomically.
This ensures that no goroutine sees these parts in an inconsistent state.</p>
<blockquote>
<p>Consider two goroutines, one is doing the <code>Store</code> operation and the other is doing the <code>Load</code> operation on the same key that the store goroutine is trying to put.</p>
<p>The goroutine performing the <code>Store</code> operation finds an empty
slot and updates the hash and then the entry by executing <code>atomic.StoreUint64(&amp;emptyb.hashes[emptyidx], hash)</code> and
<code>atomic.StorePointer(&amp;emptyb.entries[emptyidx], unsafe.Pointer(newe))</code>.</p>
<p>It is possible for the goroutine performing the <code>Load</code> operation to see the updated hash because the hash might have been written by the store goroutine at an index <code>i</code>, but the value might not have been written yet.
So, the load goroutine will not see the value despite seeing the updated hash. It will return with the empty value. This is still the expected behavior.</p>
</blockquote>
<p>The complete method is available <a href="https://github.com/puzpuzpuz/xsync/blob/main/mapof.go#L258" target="_blank" rel="noopener">here</a>
.</p>
<p>One of the key benefits of CLHT is its minimal impact on CPU cache lines during writes (store operations). This is because each store operation only modifies a single bucket. Regardless of whether it updates an existing bucket or creates a new one, only a single cache line of data is written.</p>
<h3 id="understanding-the-resize-operation">Understanding the Resize Operation</h3>
<p>Let&rsquo;s take a look at the <code>resize</code> operation which can increase or decrease the number of buckets in the map. In this section, we&rsquo;ll delve deeper into how the resize operation handles map growth.</p>
<h4 id="ensure-one-resize-at-a-time">Ensure one resize at a time</h4>
<p>There can be only one <code>resize</code> running at a time.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff79c6">if</span> !atomic.<span style="color:#50fa7b">CompareAndSwapInt64</span>(<span style="color:#ff79c6">&amp;</span>m.resizing, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Someone else started resize. Wait for it to finish.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    m.<span style="color:#50fa7b">waitForResize</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This method checks to see if an existing <code>resize</code> operation is running. <code>CompareAndSwapInt64</code> will compare the value of the field <code>resizing</code> with 0. The zero value for the field <code>resizing</code> signifies that there is no resize operation in progress.</p>
<p>If <code>resizing</code> is 0, it will be set to 1 and the <code>resize</code> operation will proceed. Else, <code>CompareAndSwapInt64</code> will fail and the goroutine will wait for the ongoing <code>resize</code> operation to finish and return.</p>
<h4 id="access-the-current-table-atomically">Access the current table atomically</h4>
<p>Consider that there is no resize operation in progress.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>table <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>mapOfTable[K, V])(atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>m.table))
</span></span><span style="display:flex;"><span>tableLen <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">len</span>(table.buckets)
</span></span></code></pre></div><p>The <code>table</code> field is an unsafe pointer that refers to <code>mapOfTable</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> MapOf[K comparable, V any] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	table        unsafe.Pointer <span style="color:#6272a4">// *mapOfTable
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p>The method accesses the <code>table</code> field to find the total number of buckets present in the table (/map). The field is accessed atomically to ensure that the consistent view of the <code>table</code> is obtained. This atomic access becomes crucial because a previous resize operation might have already changed the internal structure of the map (adding or removing buckets). By reading atomically, we avoid any inconsistencies that could lead to errors.</p>
<h4 id="increase-the-table-size-locally">Increase the table size locally</h4>
<p>The next step is to increase the table size. We already know that the field <code>table</code> needs to be operated on atomically. This means unless the new table (/method local table) is ready, this field is not touched.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> newTable <span style="color:#ff79c6">*</span>mapOfTable[K, V]
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">case</span> mapGrowHint:
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Grow the table with factor of 2.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    atomic.<span style="color:#50fa7b">AddInt64</span>(<span style="color:#ff79c6">&amp;</span>m.totalGrowths, <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    newTable = newMapOfTable[K, V](tableLen <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#bd93f9">1</span>)
</span></span></code></pre></div><p>To grow the table, a new method local table is created with twice the size of the existing table.</p>
<h4 id="remap-the-existing-keys">Remap the existing keys</h4>
<p>The next step is to go through all the buckets in the existing table and map all the keys to the new structure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; tableLen; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//remap the keys of the existing bucket at index i into the new table.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    copied <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">copyBucketOf</span>(<span style="color:#ff79c6">&amp;</span>table.buckets[i], newTable, m.hasher)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> copyBucketOf[K comparable, V any](
</span></span><span style="display:flex;"><span>	b <span style="color:#ff79c6">*</span>bucketOfPadded,
</span></span><span style="display:flex;"><span>	destTable <span style="color:#ff79c6">*</span>mapOfTable[K, V],
</span></span><span style="display:flex;"><span>	hasher <span style="color:#8be9fd;font-style:italic">func</span>(K, <span style="color:#8be9fd">uint64</span>) <span style="color:#8be9fd">uint64</span>,
</span></span><span style="display:flex;"><span>) (copied <span style="color:#8be9fd">int</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rootb <span style="color:#ff79c6">:=</span> b
</span></span><span style="display:flex;"><span>	rootb.mu.<span style="color:#50fa7b">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; entriesPerMapBucket; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> b.entries[i] <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				e <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>entryOf[K, V])(b.entries[i])
</span></span><span style="display:flex;"><span>				hash <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">shiftHash</span>(<span style="color:#50fa7b">hasher</span>(e.key, destTable.seed))
</span></span><span style="display:flex;"><span>				bidx <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint64</span>(<span style="color:#8be9fd;font-style:italic">len</span>(destTable.buckets)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">&amp;</span> hash
</span></span><span style="display:flex;"><span>				destb <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>destTable.buckets[bidx]
</span></span><span style="display:flex;"><span>				<span style="color:#50fa7b">appendToBucketOf</span>(hash, b.entries[i], destb)
</span></span><span style="display:flex;"><span>				copied<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> b.next <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			rootb.mu.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		b = (<span style="color:#ff79c6">*</span>bucketOfPadded)(b.next)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The idea behind <code>copyBucketOf</code> can be summarized as:</p>
<ul>
<li>Acquire a lock on the current bucket.</li>
<li>Iterate through the entire bucket (chained bucket(s)).</li>
<li>Calculate the hash of each entry in the linearly linked buckets.</li>
<li>Identify the bucket index based on the new table structure: <code>uint64(len(destTable.buckets)-1) &amp; hash</code></li>
<li>Add the entry (or entry pointer) to an empty slot in the existing bucket or append a new bucket.</li>
<li>Release the lock for the bucket if the <code>next</code> pointer of the current bucket is <code>nil</code>.</li>
</ul>
<h4 id="finish-resize">Finish resize</h4>
<p>The last step is to mark the resizing done.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">// Publish the new table and wake up all waiters.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>atomic.<span style="color:#50fa7b">StorePointer</span>(<span style="color:#ff79c6">&amp;</span>m.table, unsafe.<span style="color:#50fa7b">Pointer</span>(newTable))
</span></span><span style="display:flex;"><span>m.resizeMu.<span style="color:#50fa7b">Lock</span>()
</span></span><span style="display:flex;"><span>atomic.<span style="color:#50fa7b">StoreInt64</span>(<span style="color:#ff79c6">&amp;</span>m.resizing, <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>m.resizeCond.<span style="color:#50fa7b">Broadcast</span>()
</span></span><span style="display:flex;"><span>m.resizeMu.<span style="color:#50fa7b">Unlock</span>()
</span></span></code></pre></div><p>The idea can be summarized as:</p>
<ul>
<li>Atomically store the pointer to the <code>newTable</code> in the map.</li>
<li>Mark resizing done by atomically storing zero in the <code>resizing</code> field.</li>
<li>Notify waiters (other goroutines) of the completion of resize operation.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>Imagine a machine with 128 cores, where a thread on core 1 needs to update data. This update involves three cache lines, and unfortunately, all these lines are also cached by every other core.</p>
<p>In a traditional approach, this update triggers a chain reaction:</p>
<p><strong>Heavy Bus Traffic</strong></p>
<p>Core 1 writes the updated lines, causing a lot of traffic on the CPU bus, a shared pathway for communication.</p>
<p><strong>Cache Invalidation</strong></p>
<p>Since other cores have copies of these lines, cache coherence protocol kicks in. This protocol invalidates the outdated copies in other cores&rsquo; caches.</p>
<p><strong>Reloading from RAM</strong></p>
<p>Invalidated cores are forced to fetch the latest data from main memory (RAM), further increasing traffic and potentially slowing down the system.</p>
<p><em>This process, known as cache coherence traffic, can become a significant bottleneck in multi-core systems with frequent writes.</em></p>
<p>Cache-Line Hash Tables (CLHT) offer a clever solution for managing concurrent data access in multi-core processors. By keeping one bucket per CPU cache line, CLHT minimizes the disruptive effects of cache coherence traffic during write operations. With CLHT, updates primarily modify a single bucket, ensuring only one cache line is written at a time.</p>
<h3 id="mentions">Mentions</h3>
<ul>
<li><a href="https://bard.google.com/chat" target="_blank" rel="noopener">Google Bard</a>
 helped with the article.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/puzpuzpuz/xsync" target="_blank" rel="noopener">xsync</a>
</li>
<li><a href="https://infoscience.epfl.ch/record/203822" target="_blank" rel="noopener">Designing ASCY-compliant Concurrent Search Data Structures</a>
</li>
<li><a href="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/" target="_blank" rel="noopener">Cache invalidation really is one of the hardest problems in computer science</a>
</li>
</ul>

  </article>
<div class="tag-list-container">
    <div class="tag-list">
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>CPU Cache-Line</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Hash Table</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>CLHT</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Cache-Line Hash Table</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Golang</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>xsync</p>
        </a>
        
    </div>
</div>



<div class="px-2 mb-2">
  
  <script src="https://giscus.app/client.js"
    data-repo="SarthakMakhija/tech-lessons-comments"
    data-repo-id="R_kgDOJHu3mA"
    data-category="Announcements"
    data-category-id="DIC_kwDOJHu3mM4CUxhS"
    data-mapping="og:title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
  </script>
  
</div>



    </main><footer class="container p-6 mx-auto flex justify-between items-center">
  <span></span>

  <span class="text-base font-thin">
    
    tech-lessons.in Â© 2020 / Powered by  <a class="font-bold" target="_blank" href="https://gohugo.io/">Hugo</a>
    
  </span>

  <span onclick="window.scrollTo({top: 0, behavior: 'smooth'})" class="p-1 cursor-pointer">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5"
      stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M18 15l-6 -6l-6 6h12" />
    </svg>
  </span>
</footer>

<div class="search-ui absolute top-0 left-0 w-full h-full bg-white dark:bg-gray-800 hidden">
  <div class="container max-w-3xl mx-auto p-12">
    <div class="relative">
      <div class="my-4 text-center text-2xl font-bold">Search</div>

      <span class="p-2 absolute right-0 top-0 cursor-pointer close-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </svg>
      </span>
    </div>

    <input type="search" class="py-2 px-3 w-full dark:text-black border dark:border-transparent"
      placeholder="Enter search query" />

    <div class="search-results text-lg font-medium my-4 hidden">Results</div>
    <ul class="search-list my-2">

    </ul>

    <div class="no-results text-center my-8 hidden">
      <div class="text-xl font-semibold mb-2">No results found</div>
      <p class="font-light text-sm">Try adjusting your search query</p>
    </div>
  </div>
</div>





<script src="//localhost:1313/js/scripts.min.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9KKTKFQ2CM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9KKTKFQ2CM');
        }
      </script>





<script>
  const mobileMenuButton = document.querySelector('.mobile-menu-button')
  const mobileMenu = document.querySelector('.mobile-menu')
  function toggleMenu() {
    mobileMenu.classList.toggle('hidden');
    mobileMenu.classList.toggle('flex');
  }
  if(mobileMenu && mobileMenuButton){
    mobileMenuButton.addEventListener('click', toggleMenu)
  }
</script>
</body>
</html>
