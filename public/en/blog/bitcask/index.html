<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" href="/favicon.png">

  <title>
  Bitcask - A Log-Structured Hash Table - tech-lessons.in
  </title>
  <meta name="description" content="Bitcask is an embeddable key/value storage engine that is defined as a &#34;Log-Structured Hash Table&#34; in the paper that introduced it. The model of Bitcask is simple: all the key/value pairs are written to append-only files and an in-memory data structure contains a mapping between each key and the position of the value in the data file." />
  <meta name="author" content="Sarthak Makhija" />
  
     <meta property="og:image" content="/bitcask_title.webp" />
  <meta name="generator" content="Hugo 0.140.1"><link rel="stylesheet" href="/css/styles.css" />

  
  

  <meta property="og:url" content="//localhost:1313/en/blog/bitcask/">
  <meta property="og:site_name" content="tech-lessons.in">
  <meta property="og:title" content="Bitcask - A Log-Structured Hash Table">
  <meta property="og:description" content="Bitcask is an embeddable key/value storage engine that is defined as a &#34;Log-Structured Hash Table&#34; in the paper that introduced it. The model of Bitcask is simple: all the key/value pairs are written to append-only files and an in-memory data structure contains a mapping between each key and the position of the value in the data file.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2023-05-04T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-05-04T00:00:00+00:00">
    <meta property="article:tag" content="Bitcask">
    <meta property="article:tag" content="Storage Engine">
    <meta property="article:tag" content="Log Structured">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Bitcask - A Log-Structured Hash Table">
  <meta name="twitter:description" content="Bitcask is an embeddable key/value storage engine that is defined as a &#34;Log-Structured Hash Table&#34; in the paper that introduced it. The model of Bitcask is simple: all the key/value pairs are written to append-only files and an in-memory data structure contains a mapping between each key and the position of the value in the data file.">

  
  <meta itemprop="name" content="Bitcask - A Log-Structured Hash Table">
  <meta itemprop="description" content="Bitcask is an embeddable key/value storage engine that is defined as a &#34;Log-Structured Hash Table&#34; in the paper that introduced it. The model of Bitcask is simple: all the key/value pairs are written to append-only files and an in-memory data structure contains a mapping between each key and the position of the value in the data file.">
  <meta itemprop="datePublished" content="2023-05-04T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-05-04T00:00:00+00:00">
  <meta itemprop="wordCount" content="2487">
  <meta itemprop="keywords" content="Bitcask,Storage Engine,Log Structured">

  
</head>
<body class="dark:bg-gray-800 dark:text-white relative flex flex-col min-h-screen"><header class="container flex justify-between md:justify-between gap-4 flex-wrap p-6 mx-auto relative">
  <a href="//localhost:1313/en/" class="capitalize font-extrabold text-2xl">
    
    <img src="/logo.png" alt="tech-lessons.in" class="h-8 max-w-full" />
    
  </a>
  <button class="mobile-menu-button md:hidden">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <line x1="4" y1="8" x2="20" y2="8" />
      <line x1="4" y1="16" x2="20" y2="16" />
    </svg>
  </button>
  <ul class="mobile-menu absolute z-10 px-6 pb-6 md:p-0 top-full left-0 w-full md:w-auto md:relative hidden md:flex flex-col md:flex-row items-end md:items-center gap-4 lg:gap-6 bg-white dark:bg-gray-800">

    
    <li><a href="/en/">Home</a></li>
    
    <li><a href="/en/blog">Blogs</a></li>
    
    <li><a href="/en/page/about/">About Me</a></li>
    
    <li><a href="/en/page/projects/">My projects</a></li>
    

    

    
    <li class="grid place-items-center">
      <span class="open-search inline-block cursor-pointer">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <circle cx="10" cy="10" r="7" />
          <line x1="21" y1="21" x2="15" y2="15" />
        </svg>
      </span>
    </li>
    

    
  </ul>
</header>
<main class="flex-1">
  
  

  
  <div class="relative max-w-5xl mx-auto px-4">
    <img src="/bitcask_title.webp" class="rounded-lg shadow-sm w-full object-contain" />
    
    <figcaption class="font-extralight text-xs"><i>Background by Suzy Hazelwood on Pexels</i></figcaption>
    
    
    <div class="absolute top-4 right-8 rounded shadow bg-white text-gray-900 dark:bg-gray-900 dark:text-white px-2 py-0.5">
      
  
    May 4, 2023
  


    </div>
    
  </div>
  

  <article class="prose lg:prose-lg mx-auto my-8 dark:prose-dark px-4 max-w-5xl">

    <h1 class="text-2xl font-bold mb-2">Bitcask - A Log-Structured Hash Table</h1>
    
    <h5 class="text-sm flex items-center flex-wrap">
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <rect x="4" y="5" width="16" height="16" rx="2" />
        <line x1="16" y1="3" x2="16" y2="7" />
        <line x1="8" y1="3" x2="8" y2="7" />
        <line x1="4" y1="11" x2="20" y2="11" />
        <rect x="8" y="15" width="2" height="2" />
      </svg>
      Posted on 
  
    May 4, 2023
  


      
        &nbsp;&bull;&nbsp;
      
      <svg xmlns="http://www.w3.org/2000/svg" class="mr-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <circle cx="12" cy="12" r="9" />
        <polyline points="12 7 12 12 15 15" />
      </svg>
      12&nbsp;minutes
      &nbsp;&bull;
      <svg xmlns="http://www.w3.org/2000/svg" class="mx-1" width="16" height="16" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <path d="M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <path d="M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" />
        <line x1="3" y1="6" x2="3" y2="19" />
        <line x1="12" y1="6" x2="12" y2="19" />
        <line x1="21" y1="6" x2="21" y2="19" />
      </svg>
      2487&nbsp;words
      
    </h5>
    

    <details id="TableOfContents" class="px-4 mt-4 bg-gray-100 dark:bg-gray-700 rounded toc">
    <summary class="flex items-center font-bold py-2 px-4 cursor-pointer justify-between select-none text-black dark:text-white">
      <span>Table of contents</span>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-down" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <polyline points="6 9 12 15 18 9"></polyline>
     </svg>
    </summary>

    <ul class="mt-2 pb-4">
        

        
        <li>
        <a href="#bitcask-components">Bitcask components</a>
        

        
        <ul>
            <li>
        <a href="#append-only-data-files">Append-only data files</a>
        

        
        </li><li>
        <a href="#keydir">KeyDir</a>
        

        
        </li></ul>
      </li><li>
        <a href="#bitcask-write-optimized-storage-engine">Bitcask: Write-optimized storage engine</a>
        

        
        </li><li>
        <a href="#bitcask-read-optimized-storage-engine">Bitcask: Read-optimized storage engine</a>
        

        
        </li><li>
        <a href="#operations">Operations</a>
        

        
        <ul>
            <li>
        <a href="#put-putkey-value">Put: <code>put(key, value)</code></a>
        

        
        </li><li>
        <a href="#update-updatekey-value">Update: <code>update(key, value)</code></a>
        

        
        </li><li>
        <a href="#delete-deletekey">Delete: <code>delete(key)</code></a>
        

        
        </li><li>
        <a href="#get-getkey">Get: <code>get(key)</code></a>
        

        
        </li></ul>
      </li><li>
        <a href="#merge-and-compaction">Merge and compaction</a>
        

        
        </li><li>
        <a href="#hint-file">Hint file</a>
        

        
        </li><li>
        <a href="#conclusion">Conclusion</a>
        

        
        </li><li>
        <a href="#code">Code</a>
        

        
        </li><li>
        <a href="#references">References</a>
        </li></ul>
  </details>

    <p>Bitcask is an embeddable key/value storage engine that is defined as a &ldquo;Log-Structured Hash Table&rdquo; in the paper that introduced it. Bitcask follows a simple model: all the
key/value pairs are written to <em>append-only files</em>, and an in-memory data structure contains a mapping between each key and the position of the value in the data file.</p>
<p>Let&rsquo;s understand the different components of Bitcask.</p>
<h3 id="bitcask-components">Bitcask components</h3>
<p>Bitcask is a straightforward model to understand. It consists of two components:</p>
<ol>
<li>Append-only data files</li>
<li>In-memory structure called <code>KeyDir</code> that maps each key to its value position in the data file</li>
</ol>
<p>Let&rsquo;s understand both these components.</p>
<h4 id="append-only-data-files">Append-only data files</h4>
<p>A bitcask instance consists of multiple data files on a disk. At any moment, only one file is active for writing. When that file meets a size threshold, it will be closed, and a new active file will be created.
Once a file is closed, it is considered immutable and will never be opened for writing again.</p>
<figure>
    <img class="align-center-exclude-width-change" src="/bitcask_data_files.webp" /> 
</figure>
<p>The active file is written by appending, which means sequential writes are performed on disk.
The format that is written for each key/value entry is simple:</p>
<pre><code>┌─────┬───────────┬──────────┬────────────┐───────┐───────┐
│ CRC │ timestamp │ key_size │ value_size │ key   │value  │
└─────┴───────────┴──────────┴────────────┘───────┘───────┘
</code></pre>
<p>Every write involves appending a new entry to the active file. Even deletion is an append operation that involves writing a particular tombstone value.
Thus, a Bitcask data file is a linear sequence of these entries.</p>
<h4 id="keydir">KeyDir</h4>
<p><code>KeyDir</code> is simply a hash table that maps every key in Bitcask to a fixed-size structure giving the file, offset, and size of the most recently written entry for that key.</p>
<figure>
    <img class="align-center-exclude-width-change" src="/bitcask_keydir.webp" /> 
</figure>
<p>Let&rsquo;s understand why Bitcask is both write and read-optimized.</p>
<h3 id="bitcask-write-optimized-storage-engine">Bitcask: Write-optimized storage engine</h3>
<p>In Bitcask, each write results in a new entry being appended to a file. To do this, the underlying file is opened in the <em>APPEND</em> mode, and each entry is written to an increasing offset in the file.
Thus, Bitcask performs sequential writes to the disk.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewStore</span>(filePath <span style="color:#8be9fd">string</span>) (<span style="color:#ff79c6">*</span>Store, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>   writer, err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">OpenFile</span>(filePath, os.O_WRONLY|os.O_APPEND, <span style="color:#bd93f9">0644</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>Store{writer: writer}, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (store <span style="color:#ff79c6">*</span>Store) <span style="color:#8be9fd;font-style:italic">append</span>(bytes []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>   bytesWritten, err <span style="color:#ff79c6">:=</span> store.writer.<span style="color:#50fa7b">Write</span>(bytes)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> bytesWritten &lt; <span style="color:#8be9fd;font-style:italic">len</span>(bytes) {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;Could not append %v bytes&#34;</span>, <span style="color:#8be9fd;font-style:italic">len</span>(bytes)))
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The image below highlights the throughput difference between sequential and random writes on an NVMe SSD; the difference would be much higher on an HDD.</p>
<figure>
    <img class="align-center" src="/sequential-random-write.png" /> 
    <figcaption class="figcaption">Sequential write throughput > Random write throughput</figcaption>
</figure>
<p>Bitcask is write-optimized because it performs sequential writes to disk.</p>
<h3 id="bitcask-read-optimized-storage-engine">Bitcask: Read-optimized storage engine</h3>
<p>Bitcask maintains all the keys in RAM in a data structure called <code>KeyDir</code>. A <code>KeyDir</code> is simply a hash table that maps every key in Bitcask to a fixed-size structure giving the file, offset, and size of the most recently written entry for that key.</p>
<p>One can imagine KeyDir to have the following structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> KeyDirectory[Key config.BitCaskKey] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   entryByKey <span style="color:#8be9fd;font-style:italic">map</span>[Key]<span style="color:#ff79c6">*</span>Entry
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Entry <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   FileId      <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>   Offset      <span style="color:#8be9fd">int64</span>
</span></span><span style="display:flex;"><span>   EntryLength <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>   Timestamp   <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To read the value for a key a lookup operation is performed in the <code>KeyDir</code> to get the datafile and the value offset within it.
Once the <code>Entry</code> corresponding to the key is found in the <code>KeyDir</code>, a read operation is performed in the file identified by the <code>Entry.FileId</code>. This read operation involves performing a <code>Seek</code> to the offset defined by <code>Entry.Offset</code> in the file and then reading the entire byte slice <code>([]byte)</code> identified by the <code>Entry.EntryLength</code>.
The correctness of the value retrieved is checked against the CRC stored and the value is then returned to the client.</p>
<p>This operation is fast as it involves performing a single disk seek. It can be made faster by using <a href="https://en.wikipedia.org/wiki/Readahead" target="_blank" rel="noopener">read-ahead</a>
 system call.</p>
<p>The read operation can be represented with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>KVStore[Key]) <span style="color:#50fa7b">Get</span>(key Key) ([]<span style="color:#8be9fd">byte</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>   entry, ok <span style="color:#ff79c6">:=</span> kv.keyDirectory.<span style="color:#50fa7b">Get</span>(key)                                                       (<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> ok {
</span></span><span style="display:flex;"><span>      storedEntry, err <span style="color:#ff79c6">:=</span> kv.segments.<span style="color:#50fa7b">Read</span>(entry.FileId, entry.Offset, entry.EntryLength)     (<span style="color:#bd93f9">2</span>) 
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>         <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> storedEntry.Value, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;Key %v does not exist&#34;</span>, key))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Step 1 performs a lookup in the <code>KeyDir</code>, and if an entry is present in the hash table, a disk read is performed in the file identified by the <code>entry.FileId</code> at an offset identified by <code>entry.Offset</code>.</p>
<h3 id="operations">Operations</h3>
<p>Let&rsquo;s understand various operations supported by Bitcask.</p>
<h4 id="put-putkey-value">Put: <code>put(key, value)</code></h4>
<p>Every put operation appends the key/value pair to the active data file. Once the append operation to the data file is done, a new entry is created in the <code>KeyDir</code>
that maps the key to a fixed structure which contains the active <code>fileId</code>, <code>value size</code>, <code>value position</code> and <code>timestamp</code>.</p>
<p>The approach can be implemented as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>KVStore[Key]) <span style="color:#50fa7b">Put</span>(key Key, value []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>   appendEntryResponse, err <span style="color:#ff79c6">:=</span> kv.segments.<span style="color:#50fa7b">Append</span>(key, value)                            (<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   kv.keyDirectory.<span style="color:#50fa7b">Put</span>(key, <span style="color:#50fa7b">NewEntryFrom</span>(appendEntryResponse))                           (<span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li><code>kv.segments.Append(key, value)</code> appends the key/value pair to the active segment(/data file)</li>
<li><code>kv.keyDirectory.Put(key, NewEntryFrom(appendEntryResponse))</code> creates a new entry in the <code>KeyDirectory</code></li>
</ol>
<blockquote>
<p>My implementation uses the term Segment instead of Datafile and KeyDirectory instead of KeyDir.</p>
</blockquote>
<p><strong>Appending to the active segment</strong></p>
<p>Let&rsquo;s look at <code>kv.segments.Append</code>.</p>
<p>Before the key/value pair can be appended to the active segment file, the size of the active segment is checked against the maximum allowed size for a segment.
If the active segment size has crossed the size threshold, it is rolled over (3). Rollover of the active segment involves creating a new active segment and adding the current active segment to
the collection of inactive segments.</p>
<p>The key/value pair is then appended to the active segment. (4)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Segments[Key config.BitCaskKey] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   activeSegment       <span style="color:#ff79c6">*</span>Segment[Key]
</span></span><span style="display:flex;"><span>   inactiveSegments    <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">uint64</span>]<span style="color:#ff79c6">*</span>Segment[Key]
</span></span><span style="display:flex;"><span>   maxSegmentSizeBytes <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> AppendEntryResponse <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   FileId      <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>   Offset      <span style="color:#8be9fd">int64</span>
</span></span><span style="display:flex;"><span>   EntryLength <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (segments <span style="color:#ff79c6">*</span>Segments[Key]) <span style="color:#50fa7b">Append</span>(key Key, value []<span style="color:#8be9fd">byte</span>) (<span style="color:#ff79c6">*</span>AppendEntryResponse, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> segments.<span style="color:#50fa7b">maybeRolloverActiveSegment</span>(); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {                           (<span style="color:#bd93f9">3</span>)            
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> segments.activeSegment.<span style="color:#8be9fd;font-style:italic">append</span>(NewEntry[Key](key, value, segments.clock))         (<span style="color:#bd93f9">4</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Encoding</strong></p>
<p>The entry needs to be encoded to append it to the active segment.</p>
<p>Encoding is converting the key/value pair to a byte slice that can be written to the disk.
The encoding scheme consists of the following structure:</p>
<pre><code>┌───────────┬──────────┬────────────┬─────┬───────┐
│ timestamp │ key_size │ value_size │ key │ value │
└───────────┴──────────┴────────────┴─────┴───────┘
</code></pre>
<p><code>timestamp</code>, <code>key_size</code>, <code>value_size</code> consist of 32 bits each. The value ([]byte) consists of the value provided by the user and a byte for tombstone, that
is used to signify if the key/value pair is deleted.</p>
<blockquote>
<p>My implementation does not store CRC.</p>
</blockquote>
<p>The encoding operation can be represented as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Entry[Key config.Serializable] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   key       Key
</span></span><span style="display:flex;"><span>   value     valueReference
</span></span><span style="display:flex;"><span>   timestamp <span style="color:#8be9fd">uint32</span>
</span></span><span style="display:flex;"><span>   clock     clock.Clock
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> valueReference <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   value     []<span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>   tombstone <span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (entry <span style="color:#ff79c6">*</span>Entry[Key]) <span style="color:#50fa7b">encode</span>() []<span style="color:#8be9fd">byte</span> {
</span></span><span style="display:flex;"><span>   serializedKey <span style="color:#ff79c6">:=</span> entry.key.<span style="color:#50fa7b">Serialize</span>()
</span></span><span style="display:flex;"><span>   keySize, valueSize <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(serializedKey)), <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">len</span>(entry.value.value))<span style="color:#ff79c6">+</span>tombstoneMarkerSize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   encoded <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">byte</span>, reservedTimestampSize<span style="color:#ff79c6">+</span>reservedKeySize<span style="color:#ff79c6">+</span>reservedValueSize<span style="color:#ff79c6">+</span>keySize<span style="color:#ff79c6">+</span>valueSize)
</span></span><span style="display:flex;"><span>   <span style="color:#8be9fd;font-style:italic">var</span> offset <span style="color:#8be9fd">uint32</span> = <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   littleEndian.<span style="color:#50fa7b">PutUint32</span>(encoded, <span style="color:#8be9fd;font-style:italic">uint32</span>(<span style="color:#8be9fd;font-style:italic">int</span>(entry.clock.<span style="color:#50fa7b">Now</span>())))
</span></span><span style="display:flex;"><span>   offset = offset <span style="color:#ff79c6">+</span> reservedTimestampSize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   littleEndian.<span style="color:#50fa7b">PutUint32</span>(encoded[offset:], keySize)
</span></span><span style="display:flex;"><span>   offset = offset <span style="color:#ff79c6">+</span> reservedKeySize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   littleEndian.<span style="color:#50fa7b">PutUint32</span>(encoded[offset:], valueSize)
</span></span><span style="display:flex;"><span>   offset = offset <span style="color:#ff79c6">+</span> reservedValueSize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#8be9fd;font-style:italic">copy</span>(encoded[offset:], serializedKey)
</span></span><span style="display:flex;"><span>   offset = offset <span style="color:#ff79c6">+</span> keySize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#8be9fd;font-style:italic">copy</span>(encoded[offset:], <span style="color:#8be9fd;font-style:italic">append</span>(entry.value.value, entry.value.tombstone))
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> encoded
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>The little-endian system stores the least-significant byte at the smallest address.</p>
</blockquote>
<p><strong>Putting in the KeyDirectory</strong></p>
<p>Let&rsquo;s look at the last step of put operation, <code>kv.keyDirectory.Put</code>.</p>
<p>After the append operation is done, a new entry is created and inserted into the hashmap.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> KeyDirectory[Key config.BitCaskKey] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>   entryByKey <span style="color:#8be9fd;font-style:italic">map</span>[Key]<span style="color:#ff79c6">*</span>Entry
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (keyDirectory <span style="color:#ff79c6">*</span>KeyDirectory[Key]) <span style="color:#50fa7b">Put</span>(key Key, value <span style="color:#ff79c6">*</span>Entry) {
</span></span><span style="display:flex;"><span>   keyDirectory.entryByKey[key] = value
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="update-updatekey-value">Update: <code>update(key, value)</code></h4>
<p>The update operation is similar to the put operation. It appends the key/value pair to the active segment file and updates the existing entry in the <code>KeyDirectory</code>
with the new position and possibly with the new <code>fileId</code>.</p>
<p>All the key/value storage engines that rely on append-only log files can have the same key with different values across different data files. To remove old entries,
merge and compaction process has to be introduced to merge data files and produce a set of data files containing only the latest versions of each present key.</p>
<h4 id="delete-deletekey">Delete: <code>delete(key)</code></h4>
<p>Delete operation appends a new entry to the active segment with a tombstone marker to signify deletion. Once the entry is appended to the active segment, an in-place delete is performed in the <code>KeyDirectory</code> to remove the key.</p>
<p>The approach can be represented with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>KVStore[Key]) <span style="color:#50fa7b">Delete</span>(key Key) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> _, err <span style="color:#ff79c6">:=</span> kv.segments.<span style="color:#50fa7b">AppendDeleted</span>(key); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {                               (<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   kv.keyDirectory.<span style="color:#50fa7b">Delete</span>(key)                                                             (<span style="color:#bd93f9">4</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (segments <span style="color:#ff79c6">*</span>Segments[Key]) <span style="color:#50fa7b">AppendDeleted</span>(key Key) (<span style="color:#ff79c6">*</span>AppendEntryResponse, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> segments.<span style="color:#50fa7b">maybeRolloverActiveSegment</span>(); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {                           (<span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> segments.activeSegment.<span style="color:#8be9fd;font-style:italic">append</span>(NewDeletedEntry[Key](key, segments.clock))         (<span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> NewDeletedEntry[Key config.Serializable](key Key, clock clock.Clock) <span style="color:#ff79c6">*</span>Entry[Key] {
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>Entry[Key]{
</span></span><span style="display:flex;"><span>      key:       key,
</span></span><span style="display:flex;"><span>      value:     valueReference{value: []<span style="color:#8be9fd">byte</span>{}, tombstone: <span style="color:#bd93f9">1</span>},
</span></span><span style="display:flex;"><span>      timestamp: <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>      clock:     clock,
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above code can be summarized as:</p>
<ol>
<li>The <code>Delete</code> method of KVStore calls the <code>AppendDeleted</code> of <code>Segments</code></li>
<li>The <code>AppendDeleted</code> method rolls over the active segment if the size of the active segment has crossed the segment size threshold</li>
<li>The <code>AppendDeleted</code> method creates an <code>Entry</code> with the <code>tombstone</code> byte set to 1 to indicate the deletion</li>
<li>After the entry is appended to the active segment, the key is deleted from the <code>KeyDirectory</code></li>
</ol>
<p>Because the delete operation is append-only, the merge and compaction process removes the deleted entries from the segment files and retains only the non-deleted keys.</p>
<blockquote>
<p>My implementation of delete maintains a separate tombstone byte to indicate the deletion. However, Bitcask paper mentions appending a particular tombstone value.</p>
</blockquote>
<h4 id="get-getkey">Get: <code>get(key)</code></h4>
<p>To read the value for a key, a lookup operation is performed in the <code>KeyDir</code> to get the datafile and the value offset within it.
Once the <code>Entry</code> corresponding to the key is found in the <code>KeyDir</code>, a read operation is performed in the file identified by the <code>Entry.FileId</code>. This read operation involves performing a <code>Seek</code> to the offset defined by <code>Entry.Offset</code> in the file and then reading the entire byte slice <code>([]byte)</code> identified by the <code>Entry.EntryLength</code>.</p>
<p>The read operation can be represented with the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>KVStore[Key]) <span style="color:#50fa7b">Get</span>(key Key) ([]<span style="color:#8be9fd">byte</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>   entry, ok <span style="color:#ff79c6">:=</span> kv.keyDirectory.<span style="color:#50fa7b">Get</span>(key)                                                     (<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> ok {
</span></span><span style="display:flex;"><span>      storedEntry, err <span style="color:#ff79c6">:=</span> kv.segments.<span style="color:#50fa7b">Read</span>(entry.FileId, entry.Offset, entry.EntryLength)   
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>         <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> storedEntry.Value, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;Key %v does not exist&#34;</span>, key))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (segments <span style="color:#ff79c6">*</span>Segments[Key]) <span style="color:#50fa7b">Read</span>(fileId <span style="color:#8be9fd">uint64</span>, offset <span style="color:#8be9fd">int64</span>, size <span style="color:#8be9fd">uint32</span>) (<span style="color:#ff79c6">*</span>StoredEntry, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> fileId <span style="color:#ff79c6">==</span> segments.activeSegment.fileId {                                              (<span style="color:#bd93f9">2</span>) 
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> segments.activeSegment.<span style="color:#50fa7b">read</span>(offset, size)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   segment, ok <span style="color:#ff79c6">:=</span> segments.inactiveSegments[fileId]                                          (<span style="color:#bd93f9">3</span>) 
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> ok {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> segment.<span style="color:#50fa7b">read</span>(offset, size)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;Invalid file id %v&#34;</span>, fileId))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (segment <span style="color:#ff79c6">*</span>Segment[Key]) <span style="color:#50fa7b">read</span>(offset <span style="color:#8be9fd">int64</span>, size <span style="color:#8be9fd">uint32</span>) (<span style="color:#ff79c6">*</span>StoredEntry, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>   bytes, err <span style="color:#ff79c6">:=</span> segment.store.<span style="color:#50fa7b">read</span>(offset, size)                                            (<span style="color:#bd93f9">4</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   storedEntry <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">decode</span>(bytes)                                                              (<span style="color:#bd93f9">5</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> storedEntry, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above code can be summarized as:</p>
<ol>
<li>Perform a lookup in the <code>KeyDirectory</code> and get an entry containing the <code>fileId</code>, <code>entry position</code> and <code>entry size</code></li>
<li>Read from the active segment if the <code>fileId</code> matches the active segment&rsquo;s <code>fileId</code></li>
<li>Read from the inactive segment if the <code>fileId</code> matches one of the inactive segment&rsquo;s <code>fileId</code></li>
<li>Perform a <code>File.Read()</code> and get a byte slice</li>
<li><code>decode</code> the read bytes to get the actual entry</li>
</ol>
<h3 id="merge-and-compaction">Merge and compaction</h3>
<p>Any storage engine model built on top of append-only data files like LSM or bitcask may use up much disk space over time, since new values are appended to the files without touching
the old ones. Therefore, a process for compaction that is referred to as &ldquo;merging&rdquo; is required. The merge process iterates over all non-active (i.e. immutable) files in a Bitcask instance and produces a set of data files containing only
the &ldquo;live&rdquo; or the latest versions of each present key.</p>
<figure>
    <img class="align-center-exclude-width-change" src="/bitcask_merge.webp" /> 
</figure>
<p>Merge process needs to read all the immutable data files in memory, keep the live and the latest version of each key, and write the merged state
back to disk in form of new immutable data files.</p>
<p>After the merged state is written back to the disk, the in-memory state of the keys need an update because the keys now exist in a different data file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (worker <span style="color:#ff79c6">*</span>Worker[Key]) <span style="color:#50fa7b">beginMerge</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#8be9fd;font-style:italic">var</span> fileIds []<span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>   <span style="color:#8be9fd;font-style:italic">var</span> segments [][]<span style="color:#ff79c6">*</span>log.MappedStoredEntry[Key]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   fileIds, segments, err 
</span></span><span style="display:flex;"><span>              <span style="color:#ff79c6">:=</span> worker.kvStore.<span style="color:#50fa7b">ReadAllInactiveSegments</span>(worker.config.<span style="color:#50fa7b">KeyMapper</span>())    (<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#8be9fd;font-style:italic">len</span>(segments) <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">2</span> {
</span></span><span style="display:flex;"><span>      mergedState <span style="color:#ff79c6">:=</span> NewMergedState[Key]()
</span></span><span style="display:flex;"><span>      mergedState.<span style="color:#50fa7b">takeAll</span>(segments[<span style="color:#bd93f9">0</span>])                                                
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">for</span> index <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">1</span>; index &lt; <span style="color:#8be9fd;font-style:italic">len</span>(segments); index<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>         mergedState.<span style="color:#50fa7b">mergeWith</span>(segments[index])                                      (<span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      _ = worker.kvStore.<span style="color:#50fa7b">WriteBack</span>(fileIds, mergedState.valueByKey)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (kv <span style="color:#ff79c6">*</span>KVStore[Key]) <span style="color:#50fa7b">WriteBack</span>(fileIds []<span style="color:#8be9fd">uint64</span>, changes <span style="color:#8be9fd;font-style:italic">map</span>[Key]<span style="color:#ff79c6">*</span>appendOnlyLog.MappedStoredEntry[Key]) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>   writeBackResponses, err <span style="color:#ff79c6">:=</span> kv.segments.<span style="color:#50fa7b">WriteBack</span>(changes)                            (<span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   kv.keyDirectory.<span style="color:#50fa7b">BulkUpdate</span>(writeBackResponses)                                       (<span style="color:#bd93f9">4</span>)
</span></span><span style="display:flex;"><span>   kv.segments.<span style="color:#50fa7b">Remove</span>(fileIds)                                                          (<span style="color:#bd93f9">5</span>) 
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above code can be summarized as:</p>
<ol>
<li>Read all the inactive segments in the RAM</li>
<li>Perform the merge operation. <code>MergeState</code> maintains a hashmap to keep only one version of each key. The timestamp is used to decide the latest version of a key</li>
<li>Write back the merged state to new immutable data files on the disk</li>
<li>Update the <code>KeyDirectory</code> to ensure that the keys point to the updated data file</li>
<li>Remove old data files from the disk</li>
</ol>
<h3 id="hint-file">Hint file</h3>
<p>The crash recovery for a Bitcask instance will require reading all the data files and reloading the state of <code>KeyDir</code>. This process is expensive because it needs to read large data files. Bitcask proposes <strong>hint files</strong>
to speed up the recovery process (or the boot process).</p>
<p>When the merge begins, it creates a hint file next to each data file. Hint files are like the data files but instead of the values, they contain keys and the position and size of the values within the corresponding data file.
Hint files are smaller than data files because they don&rsquo;t contain values. Hence, recovery is done from hint files instead of data files.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Bitcask has a relatively simple data structure compared to <a href="/blog/wisckey_ssd_conscious_key_value_store">LSM</a>
, and it offers some great positives:</p>
<ol>
<li><strong>High write throughput</strong>: it performs sequential disk writes, offering high write throughput.</li>
<li><strong>Low latency per item read or written</strong>: all the operations require a single disk seek.</li>
<li><strong>Ease of backup and restore</strong>: since the data files are immutable, backup can be taken by copying the directory. Restoration requires nothing more than placing the data files in the desired directory.</li>
<li><strong>Crash friendliness</strong>: As the data files and the commit log are the same things in Bitcask, recovery is trivial.</li>
<li>A relatively simple model to understand.</li>
</ol>
<p>Bitcask model has a set of challenges:</p>
<ol>
<li><strong>High memory usage</strong>: Bitcask stores all the keys in RAM. Thereby the memory usage is high. However, if the keys can be partitioned the problem can be reduced to some extent.</li>
<li><strong>Huge number of open OS file handles</strong>: Get operation in Bitcask can happen from both the active and inactive segment files, and there could be large number of inactive segment files in a single Bitcask instance.
To perform a read from an inactive segment, we might want to keep the file pointer of the inactive segment file open. This can result in too many open OS file handles.</li>
</ol>
<h3 id="code">Code</h3>
<p>The code for this article is available <a href="https://github.com/SarthakMakhija/bitcask" target="_blank" rel="noopener">here</a>
.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://riak.com/assets/bitcask-intro.pdf" target="_blank" rel="noopener">Bitcask paper</a>
</li>
<li><a href="https://arpitbhayani.me/blogs/bitcask" target="_blank" rel="noopener">Bitcask article by Arpit Bhayani</a>
</li>
</ul>

  </article>
<div class="tag-list-container">
    <div class="tag-list">
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Bitcask</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Storage engine</p>
        </a>
        
        <a class="button" href="">
            <p class="tag"><i class="fa fa-fw fa-tag"></i>Log Structured</p>
        </a>
        
    </div>
</div>



<div class="px-2 mb-2">
  
  <script src="https://giscus.app/client.js"
    data-repo="SarthakMakhija/tech-lessons-comments"
    data-repo-id="R_kgDOJHu3mA"
    data-category="Announcements"
    data-category-id="DIC_kwDOJHu3mM4CUxhS"
    data-mapping="og:title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
  </script>
  
</div>



    </main><footer class="container p-6 mx-auto flex justify-between items-center">
  <span></span>

  <span class="text-base font-thin">
    
    tech-lessons.in © 2020 / Powered by  <a class="font-bold" target="_blank" href="https://gohugo.io/">Hugo</a>
    
  </span>

  <span onclick="window.scrollTo({top: 0, behavior: 'smooth'})" class="p-1 cursor-pointer">
    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" stroke-width="1.5"
      stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M18 15l-6 -6l-6 6h12" />
    </svg>
  </span>
</footer>

<div class="search-ui absolute top-0 left-0 w-full h-full bg-white dark:bg-gray-800 hidden">
  <div class="container max-w-3xl mx-auto p-12">
    <div class="relative">
      <div class="my-4 text-center text-2xl font-bold">Search</div>

      <span class="p-2 absolute right-0 top-0 cursor-pointer close-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.5"
          stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </svg>
      </span>
    </div>

    <input type="search" class="py-2 px-3 w-full dark:text-black border dark:border-transparent"
      placeholder="Enter search query" />

    <div class="search-results text-lg font-medium my-4 hidden">Results</div>
    <ul class="search-list my-2">

    </ul>

    <div class="no-results text-center my-8 hidden">
      <div class="text-xl font-semibold mb-2">No results found</div>
      <p class="font-light text-sm">Try adjusting your search query</p>
    </div>
  </div>
</div>





<script src="//localhost:1313/js/scripts.min.js"></script>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9KKTKFQ2CM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9KKTKFQ2CM');
        }
      </script>





<script>
  const mobileMenuButton = document.querySelector('.mobile-menu-button')
  const mobileMenu = document.querySelector('.mobile-menu')
  function toggleMenu() {
    mobileMenu.classList.toggle('hidden');
    mobileMenu.classList.toggle('flex');
  }
  if(mobileMenu && mobileMenuButton){
    mobileMenuButton.addEventListener('click', toggleMenu)
  }
</script>
</body>
</html>
