<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Building Blocks of LSM on tech-lessons.in</title>
    <link>//localhost:1313/en/tags/building-blocks-of-lsm/</link>
    <description>Recent content in Building Blocks of LSM on tech-lessons.in</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 10 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/en/tags/building-blocks-of-lsm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Building blocks of LSM based key/value storage engines: Introduction</title>
      <link>//localhost:1313/en/blog/building_blocks_of_lsm/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/en/blog/building_blocks_of_lsm/</guid>
      <description>&lt;h3 id=&#34;lsm-tree-overview&#34;&gt;LSM-tree: Overview&lt;/h3&gt;&#xA;&lt;p&gt;LSM-tree is a write-optimized data structure implemented by storage engines for supporting write-heavy workloads. A lot of storage&#xA;engines including &lt;a href=&#34;https://github.com/dgraph-io/badger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BadgerDB&lt;/a&gt;&#xA;, &lt;a href=&#34;https://github.com/facebook/rocksdb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RocksDB&lt;/a&gt;&#xA; and &lt;a href=&#34;https://github.com/google/leveldb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LevelDB&lt;/a&gt;&#xA; use LSM-tree as their core&#xA;data structure.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Storage engine is a software module that provides data structures for efficient reads and writes.&#xA;The two most common data structures are B+Tree (read-optimized) and LSM-tree (write-optimized).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s look at the structure of LSM-tree to understand why it is write-optimized.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building blocks of LSM based key/value storage engines: Memtable</title>
      <link>//localhost:1313/en/blog/building_blocks_of_lsm_memtable/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/en/blog/building_blocks_of_lsm_memtable/</guid>
      <description>&lt;h3 id=&#34;memtable&#34;&gt;Memtable&lt;/h3&gt;&#xA;&lt;p&gt;A fixed-size in-memory data structure that temporarily stores incoming writes until it reaches capacity. Each memtable typically&#xA;has a corresponding Write-Ahead Log (WAL) to ensure durability.&lt;/p&gt;&#xA;&lt;p&gt;Storage engines like Badger maintain an active (or current) memtable and a collection of inactive (or immutable) memtables.&#xA;When the active memtable fills up, its WAL is flushed, and the memtable becomes immutable. A new active memtable is then created&#xA;to handle subsequent writes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building blocks of LSM based key/value storage engines: WAL</title>
      <link>//localhost:1313/en/blog/building_blocks_of_lsm_wal/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/en/blog/building_blocks_of_lsm_wal/</guid>
      <description>&lt;p&gt;The Write-Ahead Log (WAL) is a fundamental component of LSM-based key-value storage engines, ensuring data durability and&#xA;enabling recovery from system failures. The concept is straightforward: a WAL is an append-only log file on disk.&#xA;In an LSM-based storage engine, every write operation, whether it&amp;rsquo;s a single key-value pair or a transactional batch, is first&#xA;recorded in the WAL before being added to the active memtable. This append-only nature of WALs allows for efficient sequential disk&#xA;access.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
